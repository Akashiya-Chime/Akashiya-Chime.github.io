[{"content":"今儿个赶上入职一天后的清明节假期，准备花一些时间总结和介绍一下我从考研二战失利到入职华为OD报道一天后的全过程，并表达一些我个人的主观感受。\nPS：刚入职一天，过了信息安全教育，所以本篇并不会涉及公司内部的情况及资料\n再战不能与偶然 这一次的考研，栽在了数学。这让我想起了多年前，高一期末考数学的那个下午，盯着每个大题只能做一半的试卷，怅然若失。\n回到家，倒也不失落，只是觉得很累，不想做任何和考试相关的东西，打打游戏，偶尔同好友出门闲逛，等着分数，也等着春招。\n说再战不能，主要是感觉自己在家待太久了，没有收入，吃家里的、用家里的，虽然父母向来支持我的选择，但另一方面我对此产生了很多的压力。家父家母工作很辛苦，如果我再战一年，我心里会很难受。\n1月底，各大学陆续开学，春招逐渐进入周期，分数还没出。偶然在群里谈及在哪找工作，想起之前使用过某求职软件，于是做了个推荐，自己也装下来看看软件现在长个啥样。和之前使用时比，这次不一样在于，进入软件的时候打开了「允许电话联系」的功能。半小时后，一个个电话接踵而至，前两个还以为是骚扰，之后尝试接了一个，问我，是不是在找工作。\n听介绍说，是华为OD，一听是华为，这大厂我一非科班无工作经验本科生怕是不得行。但是对方希望我能多了解一下，我当时也确实无事可做，于是交流转到了微信。\n之后做了很多交流，自己也下来也找了很多资料，看了许多评论，想搞清楚华为OD究竟是什么，也想知道对方为什么会给我打电话。\n其实网络上来的反馈关键词大多是「外包」，直面的解释「OD就是外包」，而外包在我了解到的互联网行业中，并不是一个喜闻乐见的词，感觉受到了很多歧视。但对于一个非科班无工作经验又想着怎么才能上川藏线投入建设的人来说，似乎并没有什么歧视的必要或者资格。\n了解的差不多了，并且能力内排除诈骗可能后，就想着试试，毕竟还是想等等成绩，而且春招也会持续一段时间，这段窗口期，想要再努力一下\n笔试 笔试就是机考算法，一共三道题，前两题各100分，第三题200分，每题的分数计算取决于用例通过比例。笔试合格的分数线是150分。\n我首先遇到的问题是编程语言的选择。其实我接触过并学过一段时间的编程语言还是挺多的，JavaScript、C/C++、Python、Golang、Rust。当时有些茫然，或者说，有些觉得无所谓，我不清楚要考察我的编程语言水平到哪种深度，自己对自己各语言的掌握水平自己也没底。HR推荐了C，所以就选择了C。\n简要地了解了一下笔试题的难度（做了两道题），然后回头开始疯狂补习C语言，这里推荐一个网站：Linux C编程一站式学习 (akaedu.github.io)。\n我开始重新审视C语言，我从最基础的地方学起。基础学习是乏味的，但语言的学习对我来说却是暗藏乐趣的，尤其是接触过的语言多了之后，我会很乐意去寻找不同语言之间的相似或不同，不仅是编程语言，自然语言也一样。我开始了解C语言的发展史，从最开始的ANSI C到C89、C99，再到新一点的C11，开始研究版本迭代增加的内容。开始去站在C语言的角度审视底层的知识，去学习一些汇编，了解汇编是怎么解释C语言的语句。又了解到结构体的泛用之处，数日地考究指针、数组指针、指针数组、函数指针、指针函数，他们指向哪里、代表什么、占了多大内存，为什么程序员使用指针作为函数的参数。我开始学习使用C语言实现基本的数据结构，去了解基本算法的智慧之处，当然，也在DFS、动态规划等算法上吃了不少苦。\n学习大概持续了一周多一点，对C语言的掌握度就已经大幅超过干学完考试那会儿，接下来就是持续的刷题。刷题刚开始的时候是痛苦的，特别是，题库和笔试都在牛客上（注：笔试题并不取自题库），牛客不像leetcode只用写函数，牛客需要自己写输入读取部分，在这个问题上踩了不少坑。\n整个过程持续了1个月，HR人挺不错的，每周都回来问问情况，跟进一下进度，在2月底3月初申请了笔试，笔试题目就不做赘述，难度就是牛客中等、较难的难度，值得注意的点在于有的题目很长很绕，搞清楚题目说的什么很费劲。\n总之，结果是好的，通过了\n面试前的准备 笔试结束等分的同时，开始准备简历以及做一个 SHL。SHL不多说，积极乐观团队友好是想看到的。而简历的修改受到了HR的巨大帮助，纠正了许多错误。\n想了想，还是想说说在改简历时候产生的一些哀愁。我还是挺自信的，在简历中放上了很多本科期间的成就：修了180个学分的庞大课程体系、参加竞赛获得的奖项，甚至是一些不多，但曾给我带来过程成就感的一些土木技能。这些东西，都不适合我将要参加的面试。当我把他们悉数从简历中删去的时候我开始思考，思考这四年的努力的结果居然对我现在的求职居然一点用处也没有，怅然若失。\n再有的准备就是围绕简历去复习项目中的知识点、技术点，这个时候我又去复习了C语言一些偏向应用的知识，去学习了基本的标准库、学习了一些调试的技巧、学习编译链接过程、静态库、动态库、Makefile，以及多线程编程、socket编程。\n差不多3月中旬，申请了面试。\n面试 流程是挺复杂的，一共有4轮面试，资格面、技术一面、技术二面、主管面，但是安排地挺紧凑，头一天晚上的资格面，第二天中午技术一面，下午技术二面，晚上跟着安排了主管面。\n简要的讲一下，资格面会问一些个人的信息以及背景，技术一面和技术二面内容差不多，会围绕简历问一些八股文、项目中的技术点，主管面就是一个考究你是否有一个良好的心态、能够胜任工作、能够融入团队以及，定薪。这里不能过多描述面试内的细节。\n入职 主管面结束的第二天收到了通过的消息，offer下来的很快，四五天的样子，offer通知一周后报道。\n这一周非常忙、非常累。先是去市里的医院做了入职体检，结果电子版报告不合规，不得不再去一趟市里拿纸质版的报告，然后填资料的时候发现需要使用招商银行的卡做工资卡，而理我最近的招商银行又在省会，所以又辗转前往省会，中途又去解决工作住房的问题。总之花了不少的车费，而且非常累。\n不过也得亏几日的辗转，按时入职了。\n踏入了华为的大门，希望，能选择是正确的吧。\n","permalink":"https://akashiya-chime.github.io/posts/%E5%8D%8E%E4%B8%BAod%E5%85%A5%E8%81%8C%E7%BB%8F%E5%8E%86/","summary":"\u003cp\u003e今儿个赶上入职一天后的清明节假期，准备花一些时间总结和介绍一下我从考研二战失利到入职华为OD报道一天后的全过程，并表达一些我个人的主观感受。\u003c/p\u003e","title":"华为OD入职经历"},{"content":"记录一些看过的标准库，以供复习和查找。\n\u0026lt;stdio.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* * fopen，成功返回文件指针，出错返回NULL并设置errno * fclose，成功返回0，出错返回EOF并设置errno * perror，将错误信息打印到标准错误输出，首先打印参数`s`所指的字符串，然后打印:号，然后根据当前`errno`的值打印错误原因 */ FILE *fopen(const char *path, const char *mode); int fclose(FILE *fp); void perror(const char *s); /* * fgetc，从指定的文件中读一个字节 * getchar，从标准输入读一个字节 * fputc，向指定的文件写一个字节 * putchar，向标准输出写一个字节 * 成功返回读到的字节，出错或者读到文件末尾时返回EOF */ int fgetc(FILE *stream); int getchar(void); int fputc(int c, FILE *stream); int putchar(int c); /* * fseek，任意移动读写位置，成功返回0，出错返回-1并设置errno * ftell，返回当前的读写位置，成功返回当前读写位置，出错返回-1并设置errno * rewind，把读写位置移到文件开头 */ int fseek(FILE *stream, long offset, int whence); long ftell(FILE *stream); void rewind(FILE *stream); /* * fgets，从指定的文件中读一行字符到调用者提供的缓冲区中 * gets，从标准输入读一行字符到调用者提供的缓冲区中 */ char *fgets(char *s, int size, FILE *stream); char *gets(char *s); /* * 用于读写记录 */ size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); /* * 格式化 I/O 函数 */ int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int sprintf(char *str, const char *format, ...); int snprintf(char *str, size_t size, const char *format, ...); \u0026lt;string.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* * strerror，错误码errnum所对应的字符串 * memset，初始化字符串 * strlen，取字符串长度 */ char *strerror(int errnum); void *memset(void *s, int c, size_t n); size_t strlen(const char *s); /* * 字符串拷贝 * C99中，memcpy使用了restrict关键字进行优化，要求传进来的指针不允许指向重叠的内存区间 */ char *strcpy(char *dest, const char *src); char *strncpy(char *dest, const char *src, size_t n); void *memcpy(void *dest, const void *src, size_t n); void *memmove(void *dest, const void *src, size_t n); /* * 连接字符串 */ char *strcat(char *dest, const char *src); char *strncat(char *dest, const char *src, size_t n); /* * 比较字符串 * 负值表示s1小于s2，0表示s1等于s2，正值表示s1大于s2 */ int memcmp(const void *s1, const void *s2, size_t n); int strcmp(const char *s1, const char *s2); int strncmp(const char *s1, const char *s2, size_t n); /* * 搜索字符串 * strchr和strrchr如果找到字符c，返回字符串s中指向字符c的指针，如果找不到就返回NULL * strstr，如果找到子串，返回值指向子串的开头，如果找不到就返回NULL */ char *strchr(const char *s, int c); char *strrchr(const char *s, int c); char *strstr(const char *haystack, const char *needle); /* * 分割字符串 */ char *strtok(char *str, const char *delim); char *strtok_r(char *str, const char *delim, char **saveptr); \u0026lt;stdlib.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* * 数值字符串转换 */ int atoi(const char *nptr); long int atol(const char *nptr); double atof(const char *nptr); long int strtol(const char *nptr, char **endptr, int base); double strtod(const char *nptr, char **endptr); /* * 内存分配 * calloc，用字节0填充 * realloc，返回新内存空间的首地址，并释放原内存空间 * alloca，不是在堆上分配空间，而是在调用者函数的栈帧上分配空间 */ void *malloc(size_t size); void *calloc(size_t nmemb, size_t size); void *realloc(void *ptr, size_t size); #include\u0026lt;alloca.h\u0026gt; void *alloca(size_t size); void free(void *ptr); /* * 求随机数 */ int rand(void) void srand(unsigned int seed); long int random(void); void srandom(unsigned int seed); /* * 数值运算 */ int abs(int i); long labs(long i); long long llabs(long long i); \u0026lt;pthread.h\u0026gt;(-lpthread) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * 线程创建 * 每一个线程都有一个唯一的线程 ID，ID 类型为 pthread_t，这个 ID 是一个无符号长整形数 * thread: 线程创建成功，会将线程 ID 写入到这个指针指向的内存中 * attr: 线程的属性，一般情况下使用默认属性即可，NULL * start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。 * arg: 作为实参传递到 start_routine 指针指向的函数内部 * 线程创建成功返回 0，创建失败返回对应的错误号 */ pthread_t pthread_self(void); int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg); /* * 线程调用 pthread_exit 终止自己 * pthread_join，线程回收，主线程调用该函数的线程将挂起等待，直到id为`thread`的线程终止 * 参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL * 线程分离，线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态 * 线程取消，特定情况下一个线程杀死另一个线程 */ void pthread_exit(void *value_ptr); int pthread_join(pthread_t thread, void **value_ptr); int pthread_detach(pthread_t tid); int pthread_cancel(pthread_t thread); /* * 互斥锁 * 互斥锁为pthread_mutex_t类型 * attr: 互斥锁的属性，一般使用默认属性即可，指定为NULL */ pthread_mutex_t mutex; int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); /* * 读写锁 * 读锁是共享的，写锁是独占的 * 写锁比读锁优先级高 */ pthread_rwlock_t rwlock; int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); /* * 条件变量 */ pthread_cond_t cond; int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); struct timespec { time_t tv_sec; /* Seconds */ long tv_nsec; /* Nanoseconds [0 .. 999999999] */ }; int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); int pthread_cond_signal(pthread_cond_t *cond); // 至少有一个被解除阻塞 int pthread_cond_broadcast(pthread_cond_t *cond); // 被阻塞的线程全部解除阻塞 \u0026lt;semaphore.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 /* * 信号量 semaphore * PV操作，P请求资源，资源量-1[wait(-1)]，V释放资源，资源量+1[post(+1)] */ sem_t sem; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *sval); \u0026lt;sys/socket.h\u0026gt; / \u0026lt;winsock2.h\u0026gt;(ws2_32.dll) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define AF_INET // IPv4 格式的 IP 地址 domain #define AF_INET6 // IPv6 格式的 IP 地址 domain #define SOCK_STREAM // 面向字节流，用于TCP type #define SOCK_DGRAM // 面向数据报，用于UDP type typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; typedef unsigned short int sa_family_t; struct in_addr { in_addr_t s_addr; }; // 在写数据的时候不好用 struct sockaddr { sa_family_t sa_family; // 地址族协议, ipv4 char sa_data[14]; // 端口(2字节) + IP地址(4字节) + 填充(8字节) } // sizeof(struct sockaddr) == sizeof(struct sockaddr_in) // 使用下面结构体后使用强制类型转换 struct sockaddr_in { sa_family_t sin_family; /* 地址族协议: AF_INET */ in_port_t sin_port; /* 端口, 2字节-\u0026gt; 大端 */ struct in_addr sin_addr; /* IP地址, 4字节 -\u0026gt; 大端 */ /* 填充 8字节 */ unsigned char sin_zero[sizeof (struct sockaddr) - sizeof(sin_family) - sizeof (in_port_t) - sizeof (struct in_addr)]; }; // 创建套接字，protocol一般写0 int socket(int domain, int type, int protocol); // 将文件描述符和本地的IP与端口进行绑定 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 给监听的套接字设置监听 int listen(int sockfd, int backlog); // 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)\tint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 接收数据 ssize_t read(int sockfd, void *buf, size_t size); ssize_t recv(int sockfd, void *buf, size_t size, int flags); // 发送数据的函数 ssize_t write(int fd, const void *buf, size_t len); ssize_t send(int fd, const void *buf, size_t len, int flags); // 成功连接服务器之后, 客户端会自动随机绑定一个端口 // 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); \u0026lt;arpa/inet.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 将一个短整形从主机字节序 -\u0026gt; 网络字节序 uint16_t htons(uint16_t hostshort);\t// 将一个整形从主机字节序 -\u0026gt; 网络字节序 uint32_t htonl(uint32_t hostlong);\t// 将一个短整形从网络字节序 -\u0026gt; 主机字节序 uint16_t ntohs(uint16_t netshort) // 将一个整形从网络字节序 -\u0026gt; 主机字节序 uint32_t ntohl(uint32_t netlong); // 主机字节序的IP地址是字符串, 网络字节序IP地址是整形 int inet_pton(int af, const char *src, void *dst); // 将大端的整形数, 转换为小端的点分十进制的IP地址 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); // 点分十进制IP -\u0026gt; 大端整形 in_addr_t inet_addr (const char *cp); // 大端整形 -\u0026gt; 点分十进制IP char* inet_ntoa(struct in_addr in); \u0026lt;unistd.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 // 关闭置顶文件描述符的文件 int close(int fd); // 读取文件内容并将其保存在指定的缓冲区位置 ssize_t read(int fd, void *buf, size_t size); // 将指定的内容写入文件 ssize_t write(int fd, const void *buf, size_t size); // sleep 几秒 unsigned sleep (unsigned seconds); // sleep 几微妙 int usleep(unsigned useconds) \u0026lt;math.h\u0026gt;(-lm) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 double sin(double angle); double cos(double angle); double tan(double angle); double asin(double angle); double acos(double angle); double atan(double angle); double exp(double x); double log(double x); double log10(double x); double pow(double x, double y); double sqrt(double x); double floor(double x); double ceil(double x); double trunc(double x); double round(double x); double fabs(double x); double fmod(double x, double y); \u0026lt;time.h\u0026gt; 1 2 time_t time(time_t *date_time); char *ctime(const time_t *clock); ","permalink":"https://akashiya-chime.github.io/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E8%A7%81%E6%A0%87%E5%87%86%E5%BA%93/","summary":"\u003cp\u003e记录一些看过的标准库，以供复习和查找。\u003c/p\u003e","title":"C语言学习-常见标准库"},{"content":"上次的软件推荐快有两年了，如今接触的东西更多了，体验上手的软件也多了，又有了可推荐的。本文主要介绍一些正常使用免费的，较为小众的应用、Linux 到 Windows 可选的代替软件以及用于某些特定领域的软件。\n系统相关 Etcher 官网链接：balenaEtcher - Flash OS images to SD cards \u0026amp; USB drives\n一款开源的系统盘制作工具。\n如果你安装过 Windows 系统，你也许使用过微PE工具箱来制作系统盘，而 Etcher 就更适合拿来装 Linux 系统，它更加的简洁和轻量化，没有微PE工具箱里携带的很多可能会用上也可能用不上的工具，它就是个纯粹的系统盘制作工具。 Dism++ 软件获取：Chuyu-Team/Dism-Multi-language: Dism++ Multi-language Support \u0026amp; BUG Report (github.com)\n如图所示，是一个工具箱，功能还是非常多的\n能够帮我删除一下我一般没有注意到的，但又没什么用占用我磁盘空间的垃圾 比如一些临时文件、没用的日志、回收站或者是 Windows 更新文件 帮我删除系统预装的软件 虽然但是我一般用 geek 调整一些系统设置 比如关闭搜索栏、小娜、人脉、OneDrive 还有各种广告等等杂七杂八的东西 也包括去掉快捷方式小箭头、去掉管理员运行的小盾牌之类的很「妙」的小功能，很多东西可能会戳中你以前找了很久如何设置但又百度不到的痛点 也包括了一些如系统备份还原、引导修复、hosts编辑等常见的工具 SpaceSniffer 软件获取：SpaceSniffer download (uderzo.it)\n磁盘扫描，然后用图形方块来显示文件和文件夹占用的空间大小，虽然他稍微有些慢，有时候甚至会卡住，但是相较我之前找过的替代品来说，他是视觉效果最好的一个。\n由于我的电脑只有一个256G的固态，导致我时常产生剩余空间不足的焦虑，就经常会打开软件看看什么大软件占用了我的空间。\n同时也方便我去删除电脑QQ产生的没用的图片缓存。 Geek 官网：Geek Uninstaller - the best FREE uninstaller\n最喜欢，个人感觉最好用的卸载工具。简洁、快速，删除软件同时删除残留的文件夹以及注册表，还能删除系统预装的软件。\n神 系统服务控制管理器批量辅助增强工具 软件获取：https://wwn.lanzouw.com/iyoAt067zw6h 提取码：e913\n{% note danger %} 注意：这个软件如果操作不当将可能对你的系统造成严重损害，由此产生的问题本人概不负责，勿谓言之不预。 {% endnote %}\n软件的作者是b站up 有限的未知，软件的详细使用请先完整观看他的视频：自编_系统服务辅助增强工具，无限制批量修改、禁用、卸载系统服务，涉及系统服务管理、优化、备份及相关技巧，可以相当自由的操作服务，拒绝强制你接受的服务\n视频中有对该软件使用非常详细的说明，这里简单来说就是对 Windows「服务」的几乎完全掌控，你可以用它来删掉各种流氓软件在你系统中安装的各种流氓服务，也可以做到停用甚至是删除 Windows 的更新服务以及 Windows Defender。\n在你动手系统的服务时，你需要自行了解那些服务会影响到哪些东西。比如有的软件在安装或者使用时会检测 Windows 的防火墙状态，如果他发现你的防火墙没有正常开启，他就不会让你用（尤其是跟网络连接有关的应用），如果你关闭了 Windows Defender 服务，那么很有可能导致软件无法正常运作。\n但这个软件的确非常的强大，就是需要谨慎使用。 便捷工具 File Converter 官网：File Converter - Convert \u0026amp; compress everything in 2 clicks! (file-converter.org)\n一个方便的文件转换工具。相比较广为人知的格式工厂，这个软件更加的简洁，有时候相同的输出条件甚至会快一些。软件也是支持自定义输入详细配置的。如果你有视频、音频或者图片格式装换的需求，可以尝试一下。 Motrix 官网：Motrix\n一个开源的下载工具，一般是用来下载磁力链接。相比同类型知名软件 BitTorrent 来说，Motrix 界面更加养眼，看上去更加简洁，更为关键的一点在于，Motrix 设置和更新 Tracker 更加简便。如果你有下载磁力链接的需求，不妨放下吸血鬼迅雷，来试一试 Motrix。\nantdownload 一代：antdownload v3.0.6 | 克隆窝 (kelongwo.com) 二代：antdownload2 v1.0.6 | 克隆窝 (kelongwo.com)\n上面下磁力链接应对迅雷，那么现在来讲讲如何应对百度网盘。尽管百度网盘可以通过开启所谓的「优化速率」模式来稍微提升一下他允许的下载速度，但不影响他不开心的时候让你在5G网络下拥有 1KB/s 的高速下载。\nantdownload 支持批量打包下载以及多线程，而且无需登录百度网盘（但是软件得关注公众号登录），速度虽然不是拉满的，但总好过百度网盘虚伪的诚意。\n据作者说，一代停用了，建议使用二代\n命令行工具 Linux 用多了导致对终端命令行爱不释手，即便是在 Windows 下，ssh 链接服务器以及 git 来管理项目也会经常用到命令行，这促使我不停地去寻找好用的 Windows 下能用的命令行工具。\n在此之前，我们先理清一些东西，来简单地看看什么是终端、什么是终端模拟器、什么是Shell，并举些例子来帮助理解。\n终端：也就是 terminal，终端在以前是一个单独的物理设备，用以多个使用者对同一个计算机进行交互。现在的电脑上呢，终端就以软件的形式存在。比如 Windows 上的 conhost，就是我们熟悉的黑底白字： Shell：其实分了图形化的Shell和命令行的Shell，命令行Shell也被直接叫做命令行。我们通过终端与计算机的交互不是直接进行的，我们在终端中输入指令回车后，指令被送往 Shell，可以理解为是命令解释器（有点像是解释型编程语言的解释器），经过 Shell 的处理后计算机再操作，如果有返回的内容又返给 Shell，最终显示在终端上。比如 Linux 下的 bash、zsh以及 Windows 下的 cmd 和 powershell。如图，我们可以使用 conhost 打开 cmd 和 powershell（因为 conhost 默认打开的是 cmd，所以看到输入 cmd 回车后感觉没什么变化）： 终端模拟器：终端模拟器呢，说他是模拟器其实是相较物理的终端设备而言的，所以你可以叫他模拟终端设备的模拟器，是电脑软件。那么他和终端有什么区别呢，实际现在电脑软件的终端都是终端模拟器，都是现在图形化操作系统下用以模拟以前物理终端设备的软件，所以，也可以直接叫终端模拟器为终端。那么现代一点的终端有比如 Alacritty、simple terminal（st）、Wezterm 以及 Windows Terminal。 可能我说的繁琐了一些，简单说就是我们下了个终端的软件，连上了 shell，然后疯狂输出。\n下面呢就介绍一些在 Windows 下能用终端（模拟器）和命令行（也就是 Shell）工具。\n终端模拟器 Windows Terminal 前两年巨硬搓出来的，现在 win11 已经作为默认的终端了。 可怜的 conhost，人们几乎都不知道它的名字，一直管他叫 cmd\n看上去更加 Fluent 了，而且也在不断地更新，这里就不多赘述了。\nAlacritty 官网：Alacritty - A cross-platform, OpenGL terminal emulator Github 仓库：https://github.com/alacritty/alacritty\n挺好看的一个终端，配置文件使用的 yaml，配置挺方便也听全面的，主要是在 Linux 下使用，Windows 倒也能用，但有些渲染问题，最让我难受的一点是不支持 ligatures（就是连字符，比如 -\u0026gt; 渲染成一个箭头）\nWezterm Github 仓库：https://github.com/wez/wezterm\n我目前在用的一个终端，跨平台，配置文件使用 lua，配置也挺方便的，能在 Windows 下将标题栏也去掉，然后通过按住 Ctrl 加鼠标左键拖动移动，虽然跟 Alacritty 一样在 Windows 下存在一些渲染上的问题，但总体而言我的体验还是不错的。\nShell nushell 官网：| Nushell Github 仓库：https://github.com/nushell/nushell\nWindows 下是真的没什么好用的 Shell，一个 cmd，虽然挺快，但是完全不支持配色方案，看着扎眼睛；另一个 powershell，首先慢得要死，每次打开等几秒到十几秒我可忍不了，另外虽然能够有一些配置的余地，但是配置起来要多难受有多恼火（我甚至看不懂报错）。\n得亏这两年 Rust 逐渐进入视野，然后碰巧看到了 nushell。它安装方便，而且本身就很好看，配置起来非常方便，而且设置了很多 Linux 常用指令。\n我目前就是 nushell 配合 Wezterm 使用，很香啊，很香。\n{% note warning %} nushell 在 wezterm 下会出现不停换行的问题，找到的有效解决办法是修改 config.nu 中 shell_integration: false {% endnote %}\n命令行工具 scoop 官网：Scoop Github仓库：https://github.com/ScoopInstaller/scoop\nLinux 安装软件我们一般会用到包管理工具，比如 Ubuntu 下有 apt，Arch 下有 pacman，那么Windows 是不是也可以搞个包管理工具呢，然后就有人做了 scoop，或者你也听说过 Chocolatey。好处就是更好的帮助我们找到需要下载的软件以及控制软件版本（我百度一下甚至找不到 scoop 官网），然而最大的坏处是，他的软件库放在了 Github，如果你与 Github 的网络连接不佳，那么体验可能非常难受。下面介绍到的命令行工具就可以通过 scoop 来安装。\nbottom Github 仓库：https://github.com/ClementTsang/bottom\n一个跨平台的命令行图形系统监视器，类似 top、btop 或者 Windows 下的任务管理器，使用 Rust 编写，功能丰富，好看，如果你哪天不想看任务管理器了，不如来试试。\nlazygit Github 仓库：https://github.com/jesseduffield/lazygit\n一个我爱不释手的 git 工具，使用 Go 编写，我现在已经成了一个记不住 git 命令的 lazy 废物了，他几乎能让你用快捷键做所有 git 命令能做的事，比起那些图形化的 git 工具，我会更喜欢这个，相信我，如果你上手了 lazygit，你也会爱上他。\n后话 以上差不多就是这次的软件推荐了，至今还是很喜欢 Topbook 的那句话：\n让工具回归工具，让你成为你\n有了工具，最终还是得用工具干实事。\n","permalink":"https://akashiya-chime.github.io/posts/windows-%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","summary":"\u003cp\u003e上次的软件推荐快有两年了，如今接触的东西更多了，体验上手的软件也多了，又有了可推荐的。本文主要介绍一些正常使用免费的，较为小众的应用、Linux 到 Windows 可选的代替软件以及用于某些特定领域的软件。\u003c/p\u003e","title":"Windows 软件推荐"},{"content":"主要是讲一下使用 Hexo 作为工具，并使用 Github pages 作为部署方案的个人静态 Blog 搭建的大致流程。\n前言 Blog 这个东西，怎么说呢，写到现在，感觉最大的用处就是拿来总结一些东西。就像笔记，为了让自己忘了的时候回来翻一翻（我装 Arch 那篇确实是翻了很多遍。。。）。但是呢理想中的用处还是想能够去帮助一部分人，虽然我现目前能写出的东西并不算高深，但确实是自己踩了不少坑总结下来的个人经验，想来或许能在别人遇到相同问题时能够有抛砖引玉的作用。\n说到 Blog 搭建，其实工具还蛮多的。我最开始使用的是 Gridea： 它好处是用起来比较的简单，集成度比较的高，配置好后点点点就能把 Blog 发布出去。但是后来由于国内访问 Github 速度上的诟病，同步半天同步不上让我选择了放弃。之后就转到了体系上更大社区更广的 Hexo，然后就一种使用到现在。其实还有很多，诸如 Jekyll （拿 Ruby 写的）、Hugo（拿 Go 写的）、VuePress（Vue 生态中的一员）等等，前段时间还看到个建站工具叫 halo（拿 Java 写的），也是可以拿来搭 Blog 站点的。\n这次还是主要讲 Hexo，我使用的主题是 Fluid，然后丢到白嫖来的 github pages 上就成了现在看到的样子，其实步骤还蛮简单的。\n准备工作 实际上就只是装个 Node.js，下载个长期维护版安装一路下一步就完事。你说想自定义一下安装位置其实也行，但其实 node 使用得当也不是很占地方。\n哦，默认你是有 Git 的，没有的话装一个。\n搭建 装 Hexo 官网上其实有很明确是步骤，你可以直接装个全局的脚手架：\n1 $ npm install hexo-cli -g 进阶一点的话你可以装局部的，甚至不使用npm，使用yarn、npx或者pnpm也是可以的，这里就不多说了。\n初始化 使用刚装的 hexo 的脚手架新建一个 blog 项目\n1 $ hexo init \u0026lt;name\u0026gt; 这里的 \u0026lt;name\u0026gt; 就是项目的名字，随便取一个。 然后进入到项目文件夹下，先装一下依赖\n1 $ npm install 这个时候基本的项目就已经搭好了，你可以用一下命令开启一个本地的服务器查看效果：\n1 $ hexo server 主题 你可以在 hexo 的主题页面中寻找自己喜欢的主题样式，或者直接上 github 搜索也是可行的，这里以 fluid 为例讲一下一般步骤。\n一般来说装 hexo 主题有两种方式：\ngit clone 仓库到项目的 themes 文件夹下 使用 npm 作为依赖下载 fluid 推荐 hexo 5.0.0 版本以上用户使用 npm 直接安装，所以：\n1 $ npm install --save hexo-theme-fluid 然后到 node_modules 文件夹下找到 hexo-theme-fluid，把 _config.yml 复制到最外面的项目文件夹（项目根目录）下，重命名为 _config.fluid.yml。 再然后修改项目根目录下的 _config.yml 中的 theme: fluid，language: zh-CN。 由于该主题有个「关于」页，所以为了展示完全，需要新建一个 about 页：\n1 $ hexo new page about 然后修改 /source/about/index.md：\n1 2 3 4 5 6 --- title: about layout: about --- 这里写关于页的正文，支持 Markdown, HTML 关于主题细节方面的配置这里就不赘述了，官网文档写的非常丰富\n部署 本篇主要讲如何使用 hexo 的一键部署功能将项目部署到 github pages\n首先你得有个 github 账号，这里默认你有了，如果没有就注册一个。\n新建一个仓库，仓库名为 你的用户名.github.io ，进入仓库， 到 Settings -\u0026gt; Pages 中将 github pages 启用。\n然后到项目中修改 _config.yml\n1 2 3 4 5 deploy: type: \u0026#39;git\u0026#39; repo: \u0026lt;repository\u0026gt; branch: main message: \u0026#34;Site updated: {{ now(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) }})\u0026#34; 这里的 \u0026lt;repository\u0026gt; 就是你仓库的地址\n之后你就可以尝试部署：\n1 hexo clean \u0026amp;\u0026amp; hexo deploy {% note warning %}\n如果遇到说找不到你 git 的问题： 可以 1 npm install hexo-deployer-git --save 如果遇到 git 使用密码登录失败的问题 这是因为 github 在 2021 年改了政策，不让用用户名密码登录了，一种解决办法是使用 token，可以参考这篇文章 {% endnote %} 如果做完了以上步骤，那么一个基本的 Blog 站点搭建就算完成了，下面来说一说写 Blog 时的一些问题和技巧。\n写作方面的问题 一般来说文章的开头会有一些注释性的问题，例如本篇：\n1 2 3 4 5 6 7 --- title: Blog 搭建参考 tags: [Blog] categories: [编程开发] index_img: /img/Blog.png date: 2023-01-03 20:39:00 --- 里面包含了文章的标题、标签、分类、封面图片以及发表日期，除了标题和日期以外的项目可能是与你的主题配置是相关联的，建议查看主题配置相关文档细致了解。\n然后就是有的主题应该支持概要的功能，能将文章中的前面一些文字显示在 Blog 主页中，此时可以使用 \u0026lt;!--more--\u0026gt; 来截断，以免显示内容过多 文章内容就是纯纯的 markdown 了，没什么好说的，如果你在写作中涉及了 Latex 数学公式或者 Mermaid 流程图，可以查看 Hexo 相关渲染插件以及主题配置中是否有相关内容的设置。\n后话 其实写 Blog 不仅是对自我知识的归纳总结，也是知识交流的一种途径。在当下国内如百度搜索一堆没用的信息以及类似 CSDN 这类站点大家互相抄来抄去，抄到最后排版尽失、要点难寻甚至不明所以要我掏钱要我关注的一种局面下，找到一篇真正能够解决问题的文章着实是有点难，这还怎么让我在写代码的时候 Ctrl C and Ctrl V（bushi）。\n所以我还是希望能有更多的人能够真正去写一些东西，分享出来，让我们不流失好的想法或者是可贵的经验。\n","permalink":"https://akashiya-chime.github.io/posts/blog-%E6%90%AD%E5%BB%BA%E5%8F%82%E8%80%83/","summary":"\u003cp\u003e主要是讲一下使用 Hexo 作为工具，并使用 Github pages 作为部署方案的个人静态 Blog 搭建的大致流程。\u003c/p\u003e","title":"Blog 搭建参考"},{"content":"缩写能够减轻我们叙述上的负担，但是前提是能够理解缩写所表示的含义。本文对「408」科目中的常见缩写进行了汇总，以方便查找。\n按字母进行排序，嫌麻烦可以Ctrl + F\nA ACC, Accumulator, 累加器。 ACL, Access-Control List, 访问控制列表。 ADT, Abstract Data Type, 抽象数据类型。一种「数据类型」，抽象数据组织及与之相关的操作 ALOHA, Additive Link On-line HAwaii system, 一个随机接入系统。 ALU, Arithmetic and Logic Unit, 算术逻辑单元。 AOE, Activity On Edge network, 用边表示活动的网络。带权有向图中，一顶点表示事件，以有向边表示活动 AOV, Activity On Vertex network, 顶点表示活动的网络。用有向无环图表示一个工程，顶点表示活动 ARP, Address Resolution Protocol, 地址解析协议。 ARQ, Automatic Repeat reQuest, 自动重传请求。 AS, Autonomous System, 自治系统。 ASL, Average Search Length, 平均查找长度。用以描述查找算法，查找过程中进行关键字比较次数的平均值 AVL, Adelson-Velsky Landis, 人名。同平衡二叉树 B BBL, Balanced Binary Tree, 平衡二叉树。左右子树高度差的绝对值不超过1 BCD, Binary-Coded Decimal, 二进制编码的十进制数。 BFS, Breadth-First-Search, 广度优先遍历(搜索)。图的一种遍历算法 BGP, Border Gateway Protocol, 边界网关协议。 BR, Base-address Register, 基址寄存器 BSA, Basice Service Area, 基本服务区。 BSS, Basic Service Set, 基本服务集。 BST, Binary Search Tree, 二叉排序树。左 \u0026lt; 根 \u0026lt; 右 C CAM, Content Address Memory, 相联存储器。RFC, Request For Comment, 英特网的标准发布方式。 CDM, Code Division Multiplexing, 码分复用。 CDMA, Code Division Multiplexing Access, 码分多址。 CIDR, Classless Inter-Domain Routing, 无分类域间编址。 CISC, Complex Instruction Set Computer, 复杂指令系统计算机。 CPI, Clock cycle Per Instruction, 执行一条指令所需的时钟周期数。 CRC, Cyclic Redundancy Code, 循环冗余码。 CSMA, Carrier Sense Multiple Access, 载波侦听多路访问。 CSMA/CA, Carrier Sense Multiple Access with Collision Avoidence, 载波侦听多路访问/碰撞避免。 CSMA/CD, Carrier Sense Multiple Access with Collision Detection, 载波侦听多路访问/碰撞检测。 CTS, Clear To Send, 允许发送。 CU, Control Unit, 控制单元。 D DAG, Directed Acyclic Graph, 有向无环图。一个不存在环的有向图 DBMS, Data-Base Manage System, 数据库管理系统。 DFS, Depth-First-Search, 深度优先遍历(搜索)。图的一种遍历算法 DHCP, Dynamic Host Configuration Protocol, 动态主机配置协议。 DMA, Direct Memory Access, 直接存储器存取。 DNS, Domain Name System, 域名系统。 DS, Distribution System, 分配系统。 E EA, Effective Address, 有效地址。 EDVAC, Electronic Discrete Variable Automatic Computer, 离散变量自动电子计算机。 EGP, External Gateway Protocol, 外部网关协议。 ENIAC, Electronic Numerical Integrator And Computer, 世界上第一台电子数字计算机的名字。 EPROM, Erasable Programmable Read-Only Memory, 可擦除可编程只读存储器。 ESS, Extended Service Set, 扩展的服务集。 F FA, Full Adder, 全加器。基本加法单元 FAT, File Allocation Table, 文件分配表。 FCB, File Control Block, 文件控制块。 FCFS, First Come First Service, 先来先服务。调度算法的一种 FDM, Frequency Division Multiplexing, 频分复用。 FIFO, First In First Out, 先进先出。描述「队列」的操作特性 FTP, File Transfer Protocol, 文件传输协议。 G GBN, Go-Back-N, 回退N帧。 GUI, Graphic User Interface, 图形化用户界面。 H HDLC, High-level Data Link Control, 高级数据链路控制协议。 HRRN, Highest Response Ratio Next, 高响应比有限。调度算法的一种 HTTP, Hyper Text Transfer Protocol, 超文本传输协议。 I ICMP, Internet Control Message Protocol, 网际控制报文协议。 IFS, InterFrame Space, 帧间间隔。 IGMP, Internet Group Management Ptotocol, 因特网组管理协议。 IGP, Interior Gateway Protocol, 内部网关协议。 IMAP, Internet Message Access Protocol, 因特网报文存取协议。 IP, Internet Protocol, 网际协议。 IR, Instruction Register, 指令寄存器。 IX, Index Register, 变址寄存器。 K KLT, Kernel-Level Thread, 内核级线程。 KMP, Knath_Morris_Pratt, 就是三个人的名字。串的模式匹配算法，主串指针不回溯，只有模式串指针回溯 L LAN, Local Area Network, 局域网。 LFU, Least Frequently Used, 最不经常使用算法 LIFO, Last In First Out, 后进先出。描述「栈」的操作特性 LNR, Left Node Right, 左根右。中序遍历，二叉树的一种遍历方法 LRN, Left Right Node, 左右根。后序遍历，二叉树的一种遍历方法 LRU, Least Recently Used, 近期最少使用算法。 LSB, Least Significant Bit, 最低有效位。 LSD, Least Significant Digit first, 最低位优先。基数排序方法的一种 LUT, Logical Unit Table, 逻辑设备表。 M MAC, Medium Access Control, 介质访问控制。 MAR, Memory Address Register, 地址寄存器。存放访问地址 MBR, Master Boot Record, 主引导记录 MDR, Memory Data Register, 数据寄存器。暂存要从存储器中读或写的信息 MFD, Master File Directory, 主文件目录。 MFLOPS, Mega Floating-point Operations Per Second, 每秒执行多少百万次浮点运算。 MIMD, Multiple Instruction Multiple Data, 多指令多数据流。 MIME, Multipurpose Internet Mail Extensions, 多用途网络邮件扩充。 MIPS, Million Instruction Per Second, 每秒执行多少百万条指令。 MISD, Multiple Instruction Single Data, 多指令单数据流。 MM, Main Memory, 主存储器。 MQ, Multiple-Quotient Register, 乘商寄存器。 MSB, Most Significant Bit, 最高有效位。 MSD, Most Significant Digit first, 最高位优先。基数排序方法的一种 MST, Minimum-Spanning-Tree, 最小生成树。带权连通无向图的生成树中边的权值之和最小的那一个 MTU, Maximum Transmission Unit, 最大传送单元。 N NAT, Network Address Translation, 网络地址转换。 NIC, Network Interface Card, 网络接口卡(网卡)。 NLR, Node Left Right, 根左右。先序遍历，二叉树的一种遍历方法 NUMA, Nonuniform Memory Access， 非同一般存储访问。 O OS, Operation System, 操作系统。 OSI/RM, Open System Interconnection/Reference Model, 开放系统互连参考模型 OSPF, Open Shortest Path First, 开放最短路径优先。 P P2P, Peer-to-Peer, 对等协议。 PC, Program Counter, 程序计数器。 PCB, Process Control Block, 进程控制块。 PCI, Protocol Control Information, 协议控制信息。 PDU, Protocol Data Unit, 协议数据单元。 PIM, Protocol Independent Multicast, 协议无关的组播。 POP, Post Office Protocol, 邮局协议。 PPP, Point-to-Point Protocol, 点对点协议。 PSW, Program Status Word, 程序状态(字)寄存器。 R RAID, Redundant Array of Inexpensive Disks, 独立冗余磁盘阵列。 RAM, Random Access Memory, 随机存储器。 RAND, Random, 随机算法。 RAW, Read After Write, 写后读。数据冒险的一种 RBT, Red-Black Tree, 红黑树。 RFC, Request For Comment, 英特网的标准发布方式。 RIP, Routing Information Protocol, 路由信息协议。 RISC, Reduced Instruction Set Computer, 精简指令系统计算机。 ROM, Read-Only Memory, 只读存储器。 RR, Round-Robin, 时间片轮转。调度算法的一种 RTS, Request To Send, 请求发送。 RTT, Round-Trip Time, 往返时延。 S SAP, Service Access Point, 服务访问点 SDN, Software Defined Network, 软件定义网络。 SDU, Service Data Unit, 服务数据单元。 SIMD, Single Instruction Multiple Data, 单指令多数据流。 SISD, Single Instruction Single Data, 单指令单数据流。 SJF, Shortest Job First, 短作业优先。调度算法的一种 SMP, Shared-memory MultiProcessor, 共享内存多处理器。 SMTP, Simple Mail Transfer Protocol, 简单邮件传输协议。 SP, Stack Pointer, 堆栈指针。 SR, Selective Repeat, 选择重传。 SSD, Solid State Drives, 固态硬盘。 SSID, Service Set IDentifier, 服务集标识符。 SSTF, Shortest Seek Time First, 最短寻找时间优先算法。 STDM, Statistical Time Division Multiplexing, 统计时分复用。 T TCP, Transmission Control Protocol, 传输控制协议。 TDM, Time Division Multiplexing, 时分复用。 TLB, Translation Lookaside Buffer, 旁路转换缓冲(块表)。 TTL, Time To Live, 生存时间。 U UDF, User File Directory, 用户文件目录。 UDP, User Datagram Protocol, 用户数据报协议。 ULT, User-Level Thread, 用户级线程。 UMA, Uniform Memory Access, 统一存储访问。 V VLAN, Virtual Local Area Network, 虚拟局域网。 W WAR, Write After Read, 读后写。数据冒险的一种 WAW, Write Afte Write, 写后写。数据冒险的一种 WDM, Wavelength Division Multiplexing, 波分复用。 WPL, Weight Path Length, 带权路径长度。从树的根到任意结点的路径长度与该结点上的权值的乘积，称为结点的带权路径长度 X X, 操作数寄存器。 ","permalink":"https://akashiya-chime.github.io/posts/408%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E7%B4%A2%E5%BC%95/","summary":"\u003cp\u003e缩写能够减轻我们叙述上的负担，但是前提是能够理解缩写所表示的含义。本文对「408」科目中的常见缩写进行了汇总，以方便查找。\u003c/p\u003e\n\u003cp\u003e按字母进行排序，嫌麻烦可以\u003ccode\u003eCtrl + F\u003c/code\u003e\u003c/p\u003e","title":"「408」英文缩写索引"},{"content":"今年换考408试试，但是学校那么多，这个专业又卷的不行，那么应该选哪一所院校才能让我有个书读呢。该文的主要目的就是选出几个我认为值得我选择的院校进行一些数据上的对比，以增大我读上书的可能性（狗头）。\n前言 在这之前还是惯例做一些内容上的说明。\n本文主要是对我所挑出的几所院校在计算机考研相关的数据进行对比，且专业课代码为「408」，个别非408的院校提及但不为重点。\n本文对比内容主要有以下几项：\n该校对应专业的排名及评级 是否为985/211院校 该校所处地区（省市） 过往招生人数（推免人数）、报录比、招生分数 复试内容 对比表 数据来源大部分为对应院校研究生招生网公开的信息，少部分来自考研机构、平台论坛等，所以仅供参考\n表格详见：「408」院校对比\n注：表中院校链接为学校研究生招生网的官网，红色文字需要当心，背景填充是综合数据比较推荐的\n表中的院校选择是从「985」院校中刨去了非考「408」的学校又从中选区的部分，并不是所有。选取的四所「211」学校以作为对比。\n选取专业主要挑选了「计算机科学与技术」以及「软件工程」，很多学校还开设了如「人工智能」、「网络安全」等专业，这里并未完全提及，详情请见学校研究生招生网每年给出的招生目录。\n评价 从对比表中的信息可以看出很多东西，主要关注点在学校的招生人数、复试线以及分值情况。\n首先，学科排名/评级与分数并不完全成正比。我们看到表中很多「985」院校的计算机专业排名其实并不高，这很多是源于学校对该专业的重视程度。比如厦门大学，厦门大学对工科学科重视程度普遍的较低，这一点，中山大学也类似，这些学校在综合类学校中是那种偏「文科」类的。但是他们的录取分数并不低，这更多是学校品质造成的「补偿」，说明大家有意识地在考虑去考「好学校的差专业」，当然，好坏是相对的。\n第二，「985」院校的平均分数水平仍然高于「211」以及「双非」。「985」院校仍然是「211」「双非」院校考生以及二战、三战考生争夺的热门，比较大家都不想「考研还考个比自己学校差的学校」或者「我都二战了，那不得考个985」。但也有很多确实因为二战带来的经验与更多复习时间等原因更有把握上岸「985」的考生。\n第三，复录比一般会处在 0.72～0.84 之间。复录比其实是一个很重要的数据，这一点还得结合学校复试分值占比来看。「最难受的不是分数不够，而是初试过了复试被刷」。很多学校的初试复试分值占比是 6：4 但也有 7：3、5：5 的，复试占比越高，被刷的可能性就越大，对于跨考的考生来说，由于复试内容对他们并不友好，他们得花更大的功夫准备复试或者把初试的分数拉的更高。尤其是要当心华东师范这种复录比极其糟心的院校。\n此外值得关注的一些点 学校的地理位置 地理位置在择校的问题中也是一个关注点，由于计算机专业的问题，地区的发展水平确实能带来不同的就业水平，这一点就不同于其他专业，比如土木工程，土木工程其实更看中学校而且你的工作地点和你学校位置并没有一点关系。\n招生人数 看招生人数要看两个方面，一是不同学校之间的招生人数对比，招生人数越多的院校越容易避免被高分「秒杀」。虽然不是绝对的，也保不准人数多的学校就能卷得过，但人数少的的确风险性要高的多。\n关注推免人数 众所周知，这是保研的时代，很多学校招生简章中给出的招生人数是包括了推免生的，也就是保研的人，而且招收推免生的人数往往会多于考研生，所以如果有途径，最好了解一下学校招收推免生的人数以免被学校坑害。\n","permalink":"https://akashiya-chime.github.io/posts/40823%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E9%99%A2%E6%A0%A1%E5%AF%B9%E6%AF%94/","summary":"\u003cp\u003e今年换考408试试，但是学校那么多，这个专业又卷的不行，那么应该选哪一所院校才能让我有个书读呢。该文的主要目的就是选出几个我认为值得我选择的院校进行一些数据上的对比，以增大我读上书的可能性（狗头）。\u003c/p\u003e","title":"「408」23计算机考研院校对比"},{"content":"该篇汇总了研究生考试计算机科学专业基础综合（408）中，数据结构与算法所要考察的知识点，用于个人复习与总结，同时希望能够帮助到需要的人。\n身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。 ——神秀 菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。 ——慧能\n知识框架 *详细的思维导图见：数据结构与算法知识点思维导图\n数据结构与算法在408考试中占45/150分，其对考生逻辑思维能力的考察效果显著。除计算机相关专业考研外，众互联网公司也将数据结构和算法列为重点的考察内容。\n数据结构与算法的知识框架还是挺清晰的，还是有很多方法很固定的题，主要是能够理解题目内容和对相关概念十分清晰。\n说一些个人的认识：我们弄一个数据结构这个东西，是为了让它对我们有用，用什么呢，用数据。先说我们是怎么用数据，其实不过增删改查（Create Retrieve Update Delete, CRUD）。我们手上拿着一打厚厚的学生档案，我们需要找个我们知道的地方放，以方便以后能找到，或者有新的档案能放进去。这就导致我们需要考虑一些问题：\n但凡做事，都要考究一个效率问题，增删改查中，查是最体现效率的一个动作，因为删和改的前提都是把数据找到。那么，为了提升查的效率，让数据能更方便地被我们找到，那我们就可以对数据进行一些操作，比如让学生的档案按学号顺序堆放，这样我们就可以通过学号更方便地找到想要的学生档案。那么如果我们拿到的学生档案在存放之前是乱的，不按学号顺序排列咋办呢，这就催生出了算法这个东西，我们现在要干的事情是排序，所以需要排序算法。那我们找数据的时候是不是就一定得一个一个翻呢，是不是有更加方便的，让我们少翻几个就能找到目标数据的方法呢，这就催生了查找算法。我们在某些时候，为了更方便查找数据，特别是那些数据间看不出什么关系的数据，为了让他们产生关系，我们会在存数据的时候给每个数据多存一个字段，以便利我们的查找。但是多存的这个字段就造成了另一个问题：在保证效率的同时，怎么让占用的空间更少。\n知识内容 概念、定义 这一部分的内容是为了拿到一个数据结构或者算法时，能马上在脑中想起它的大概模样。\n数据结构 线性表：具有相同数据类型的n个数据的有限序列，n为表长。分顺序表和链表两种表示方式 顺序表：地址连续、依次存储 链表：非连续地址。因指针的数量和连接方式分三种 单链表：线性表的链式存储，单个指针，只能从头往后 双链表：俩指针，双向 循环链表：头尾相接 静态链表：用数组来描述链式存储，连续内存空间，指针指向地址 栈：一端操作，后进先出（LIFO，Last In First Out） 队列：两端操作，先进先出（FILO，First In Last Out） 数组：由 n 个相同类型的数据元素构成的有限序列 矩阵的压缩存储：减少空间分配，对重复元素只分配一个，另元素不分配 对称矩阵：同线性代数中的对称矩阵 三角矩阵：同线性代数中的三角矩阵，分了上三角和下三角 三对角矩阵：也叫带状矩阵，是沿主对角线均匀排布的元素带 串：字符串 模式匹配：子串的定位操作 KMP算法：模式匹配，用一个 next[j] 数组来存放可能重复的子串以达到减少比较次数，提升匹配效率的效果 PS：当子串和模式串不匹配时，主指针 i 不回溯，模式串指针 j = next[j] 二叉树：空，或者每个结点至多俩子树，是有序树 有序树：左右子树点到，则成为另一颗不同的二叉树 满二叉树：除叶子结点外，所有结点都有俩孩子（度为2），且每层装满。是特殊的完全二叉树 完全二叉树：最后一层可以不满，但结点得从左排到右 二叉排序树(Binary Search Tree, BST)：所有结点关键字：左子树 \u0026lt; 根结点 \u0026lt; 右子树 平衡二叉树(Adelson-Velsky Landis, AVL)：任意结点左右子树高度差不超过 1 先序遍历：二叉树的遍历，根左右（NLR）。中序、后序同理 层序遍历：从上往下，从左往右 线索二叉树：也分先中后，多了俩指针，一个指向前驱，一个指向后继 树的表示法：反应树中结点间关系的方法 双亲表示法：连续空间储存，结点设伪指针，指向双亲 孩子表示法：将每个结点的孩子用单链表链接起来 孩子兄弟表示法(二叉树表示法)：左侧连最左边的孩子，右边连这个孩子的兄弟（左孩子右兄弟） 带权路径长度（Weight Path Length, WPL）：从树的根到任意结点的路径长度与该结点上权值的乘积： $$ WPL = \\displaystyle\\sum_{i=1}^n w_i l_i $$\n哈夫曼树：WPL 最小的二叉树（最优二叉树） 并查集：{1,3,5,7} U {2,4,6,8} = {1,2,3,4,5,6,7,8}，用以查询某个元素是否在集合中，并且能够知道是在哪个集合中而形成的集合。而它- 的维护对象是多个集合 并查集可以进行集合合并的操作（并） 并查集可以查找元素在哪个集合中（查） 并查集维护的是一堆集合（集） 有向图：边为有向边（弧）带箭头，\u0026lt;v, w\u0026gt; \u0026lt;w, v\u0026gt; 无向图：边为无向边，(v, w) (w, v) 子图：用某图的顶点和边构成的图 生成子图：包含原图所有顶点的子图 连通：无向图，两顶点有路径，则连通；任意两顶点连通，就是连通图 连通分量：无向图的极大连通子图 强连通：有向图，两顶点往返都有路径。则强连通；任意两顶点强连通，就是强连通图 强连通分量：有向图的极大强连通子图 完全图：无向图中任意两顶点间都有边，有向图中任意两顶点间都有方向相反的两条弧 生成树：包含全部顶点的一个极小连通子图 回路（环）：A -\u0026gt; … -\u0026gt; A 简单路径：顶点不重复的路径 简单回路：除起始顶点外，顶点不重复的回路 有向树：一个顶点入度为 0，其余顶点入度为 1 图的存储： 邻接矩阵法：用二维数组储存顶点间邻接关系，适合稠密图 邻接表法：每个顶点建立一个单链表，指针指向相邻顶点，适合稀疏图 十字链表法：有向图的一种链式存储结构 邻接多重表：无向图的一种链式结构 图的遍历： 广度优先搜索/遍历(Breadth-First-Search, BFS)：找到与一个顶点相邻的所有顶点，标记哪些顶点被访问过，需要一个辅助队列 深度优先搜索/遍历(Depth-First-Search, DFS)：相邻顶点一个一个找，找完一条再找未被访问的顶点，需要一个递归工作栈 最小生成树(Minimum-Spanning-Tree, MST)：连通图的生成树，要求边的权值之和最小。最小生成树不唯一 Prim(普里姆)算法：将一离集合最近的顶点放入集合 Kruskal(克鲁斯卡尔)算法：每次选择一二叉排序树：条权值最小的边，使这条边两头连通 最短路径： Dijkstra(迪杰斯特拉)算法：求一个点到其他任意点的最短路径。类似 Prim，只是每次找下一个顶点的时候会计算一下到已知点的最短路径是否变化。负权值边不适用 Floyd(弗洛伊德)算法：求各顶点之间的最短路径。递推生成 n 阶方阵，每次以其中一顶点作为中间顶点，更新方阵。负权值边适用，但不能组成回路 有向无环图(Directed Acyclic Graph, DAG)：没有环的有向图 顶点表示活动的网络(Activity On Vertex Network, AOV)：DAG 图表示工程，其顶点表示活动 拓扑排序：DAG 只有从前往后，无从后往前 用边表示活动的网络(Activity On Edge Network, AOE)：带权有向图中，顶点表示事件，有向边表示活动，边上的权值表示完成活动的开销（其实类似土木工程经济与项目管理中的工程进度网络图，包括其中的最早发生时间、最迟开始排序时间、关键路径等，都与单代号或者双代号网络图的计算类似） 关键路径：从头到尾，路径最大的一条路径，其上的活动称为关键活动 算法 查找 平均查找长度(Avarage Search Length, ASL)：所有查找过程中进行关键字比较次数的平均值 $$ ASL = \\displaystyle\\sum_{i=1}^n P_i C_i $$\n顺序查找：也叫线性查找，就是从头到尾挨个看 折半查找：也叫二分查找，有（low，mid，high）指针，每次取中值向目标值靠 分块查找：也叫索引顺序查找，将表分块，要求块内可以无序，但块间必须有序。先在块间用顺序或折半，在块内顺序 红黑树(RBT)： 每个结点不是红就是黑 根结点、叶结点黑 没有相邻红结点 每个结点到任意叶结点的简单路径所含黑结点数量相同 B 树：也叫多路平衡查找树，所有结点的孩子个数最大值称 B 树的阶 每个结点至多 m 棵子树，之多含 m-1 个关键字 若根结点不是终端结点，则至少有两棵子树 所有叶结点出现在同一层 B+ 树：与B 树差异在于，分值结点包含他的各子结点中关键字的最大值，且所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序互相链接起来 散列表：也叫 Hash 表，就是将查找表中的关键字通过一个散列函数（Hash 函数）映射称一个地址 排序 插入排序： 直接插入排序：找到插入的位置，该位置后面的所有元素依次后移，然后插入元素 折半插入排序：相对直接插入排序，只是找位置的时候使用折半查找 希尔排序：先按一步长分若干子表，子表直接插入排序，然后减小步长重复操作，直到步长为 1 交换排序： 冒泡排序：从前往后（或相反），两两比较，找出最值，重复操作 快速排序：取一枢纽（pivot），取值比较，小左大右（或相反），左右再重复操作 选择排序： 简单选择排序：遍历全表，找其最值，固定趟数 堆排序：大根堆，使小元素不断「下坠」，小根堆相反 堆：Heap，顺序存储的完全二叉树 归并排序：将两个或以上的有序表组合成为一个新的有序表 基数排序：按照关键字的数位（个位、十位、百位……）依次进行排序 外部排序：对磁盘中的数据进行的排序 时间空间复杂度 算法的时间复杂度和空间复杂度是评价算法效率的重要手段，前者体现算法语句的频度，评价算法速度；后者评价算法所消耗的存储空间。\n我们使用 O 表示法来量化地表示（其实 O 符号应该类似高等数这部分而学中，高阶无穷小的表示法，它更关注高阶部分带来的影响，而忽略低阶部分）\n这一部分的内容主要是汇总各算法时间、空间复杂度，以方面查询，但并不鼓励死记硬背\n算法种类 时间复杂度(最好/平均/最坏) 空间复杂度 稳定性 顺序表插入/删除/查找 O(1)/O(n)/O(n) - - 单链表头插法/尾插法 O(n) - - 单链表按序号/按值查找 O(n) - - 单链表插入/删除/求表长 O(n) - - 简单模式匹配 O(nm) - - KMP算法 O(n+m) - - 二叉树的遍历 O(n) - - 邻接矩阵法 - O(n2) - 邻接表法 - O(V+2E) - BFS算法 邻接表O(V+E)/邻接矩阵O(V2) O(V) - DFS算法 邻接表O(V+E)/邻接矩阵O(V2) O(V) - Prim算法 O(V2) - - Kruskal算法 O(Elog⁡E) - - Dijkstra算法 O(V2) - - Floyd算法 O(V3) - - 拓扑排序 邻接表O(V+E)/邻接矩阵O(V2) - - 折半查找 O(log2⁡n) O(1) - 直接插入排序 O(n)/O(n2)/O(n2) O(1) 是 冒泡排序 O(n)/O(n2)/O(n2) O(1) 是 简单选择排序 O(n)/O(n2)/O(n2) O(1) 否 希尔排序 - O(1) 否 快速排序 O(nlog2⁡n)/O(nlog2⁡n)/O(n2) O(log2⁡n) 否 堆排序 O(nlog2⁡n)/O(nlog2⁡n)/O(nlog2⁡n) O(1) 否 二路归并排序 O(nlog2⁡n)/O(nlog2⁡n)/O(nlog2⁡n) O(n) 是 基数排序 O(d(n+r))/O(d(n+r))/O(d(n+r)) O(r) 是 声明 该文写作初衷是为了帮助自己复习总结学习的内容，其中不乏有错误荒谬之处，还请读者见谅，并恳请读者予以斧正，不吝赐教。\n文中部分文字、图表为个人所作，更多想表达自己的理解。如果能对读者有所启发，则为甚好，若认为我的想法有所不妥也请勿强行理解。\n参考文献 [1] 王道论坛组.2023年数据结构考研复习指导.北京:电子工业出版社,2021. [2] 严蔚敏,吴伟民.数据结构（C语言版）[M].北京:清华大学出版社,2009. [3] 王道计算机考研b站课程,2020. [4] 帅地.什么是并查集？有哪些应用？[OL].腾讯云开发者社区,2019.\n","permalink":"https://akashiya-chime.github.io/posts/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/","summary":"\u003cp\u003e该篇汇总了研究生考试计算机科学专业基础综合（408）中，数据结构与算法所要考察的知识点，用于个人复习与总结，同时希望能够帮助到需要的人。\u003c/p\u003e","title":"「408」数据结构与算法知识归纳"},{"content":"大学啊。眨眼就过去了呢……\n前言 ​ 2018 年9月入学，2020年1月寒假期间遭遇新冠疫情，在家上网课一学期，2020年9月重新回到学校，2022年5月28日完成毕业答辩。 本来想固定一段时间写个总结的，但是因为种种原因，没能实现（这的确不是因为我懒🙃），但还是写了几个假期总结的。毕业毕竟算个重要的时间节点，加上毕设也基本忙完了，也就有了本篇。 大概按照目录的几方面讲讲吧，这篇也不全是总结吧，也有些回忆和介绍的东西。\n学业与生活 上课 该校铁道专业的学业压力还是挺重的，180个学分相较其他专业意味着更多的课程，更多的上课时间。特别是大一到大三，基本每天都有课。早课八点，因为宿舍里教室远的缘故（宿舍在北区，教室在南区，徒步得15到25分钟，一个来回得3000到4000步），最好得7点起，洗漱、吃早饭、去教室。中午最晚结束12：15，下午第一讲课在14：00，下午最晚结束18：15，晚课是19：30开，一般两节课，上到21：05，有幸上过一学期我校的德语二外，结束时间是晚上21：55。\n学分 学校课程学分组成大致分成了必修、限选、选修和通时，但实际感觉没用的东西太多。通时课是一些扩展知识面的课（比如酒文化、茶文化、政治哲学导论之类的），一般安排在晚上，感觉就是学校老师为了挣外快而开设的，一星期一节并不会讲些什么东西，有的课甚至就是放视频。选修学分学校要求的不多，只有俩，我一门德语二外就有3个学分。必修就是基本的高数、线代啥的，还有一些必修的专业课，我这个专业就比如有三大力学（理论力学、材料力学、结构力学）、混凝土结构设计原理、铁路选线设计。限选是一些专业扩展课程，比如概率论（听说我们的下一届已经变成了必修）、数学建模、数值计算等等。\n衣食住行 生活方面，离不开衣食住行。 穿的……额，没校服，毕业发了文化衫不知道收不收回去，反正学士服得还回去。 我这个校区有四个食堂，但生活的北区只有一个四食堂，食堂有一二楼之分，一楼都和我高中食堂差不多，就是不会中午抢饭这个困难了，就是普遍的吃久了难吃的那种，一样的包子吃了要拉肚子。印象不好的一点在于，大二的时候，某次中午去四食堂吃饭，然后看到一只大蟑螂在炒饭窗口的炒饭上爬过去，打饭的大哥没看见，我给他指，他以为我要打一份（后来再也没吃过四食堂的炒饭）。食堂二楼一般要奢华一点，消费也要高一点。对比看，一食堂二楼是清真，二食堂二楼要好吃一些，三食堂四年去的次数一只手数得清，四食堂二楼跟一楼很像。 宿舍在六楼，上下楼就是锻炼，居住水平应该在四川是比较好的了。宿舍四人间，上床下卓，独立卫浴，有饮水机（矿泉水要么提前订要么自己从楼底搬，锻炼+1），有空调（有租金）。网络的话，可以办移动、电信、网通的宽带，年年换以使用更低的价格，但是带宽都不高，最开始是20MB，后面扩充到50MB，打打游戏还行，15-50ms的延迟，就是这两年不稳定，要么跳PING要么断流。舍友们都挺可爱的，虽然大家兴趣爱好不尽相同，但是大家包容性都很强，私认为是我们班男生宿舍里最和睦的一个了，我们一起上课一起吃饭，也一起熬夜期末复习，一起去爬山，甚至一起考研然后一起没考上😹。半夜一点躺床上，突然饿了，说「走，吃烧烤」，然后就一起穿衣服去撸串到三点才回来。这个大学，确实因为有了他们，才显得更加美好。 行的话，因为校区占地比较大，所以校内允许共享单车，但是中午吃饭的时候单车常常把去食堂的路堵满，这点让人难受。上课的话，还可以花一块钱坐小白龙，但是我对小白龙的印象极其不好，一般车都是让着走路的，小白龙的话就在人后面疯狂按喇叭，态度极差又不注意安全。学校是一校两地三校区，市内的有校车，按点发车，2块钱，还是挺方便的。（另一个校区在峨眉山下，去过一次，发现已经基本没人了，诺大的校园空空荡荡，图书馆也只有一楼的一个老师一个保安） 总的来说，虽然挂过一门课，但是总体的结业还是比较容易的，毕设的导师也比较认真，还是学到了不少知识，虽然感觉以后不太会从事这个专业的工作。\n书 读书还是很重要的一件事，读书多的人确实比读书少的人在言谈上体现出很多不同。 大学四年，总共借过图书馆103本书大部分应该是编程相关的，但还是有很多别的书，比如《中国语言学史》《和声学新编》《通过！游戏设计之道》《给忙碌者的天体物理学》《专注力：如何高效做事》《微积分的历程：从牛顿到勒贝格》《日语语言学理论研究与日本文化探析》等，还包括一部分的本专业相关的书籍。 我的读书范围还不是特别宽，但是还是有意在朝别的方面走。编程书籍是为了学习，兴趣方面大多是语言、物理相关的，最近也有看克苏鲁文学以及乐理方面的。 读书的话，还是纸质的书居多，电子版确实不如初中时候看得下去了。集体生活对我的影响还是挺大的，以前一个人，没事看书不会受到干扰，现在抗干扰的能力变弱了很多。但是最近在尝试微信读书。 我有一个目标，就是每年双十一给自己买一本书，第一年是顾樵的《数学物理方法》，很高深，可能得我的数学造诣高起来了才能看得懂；第二年是艾思奇的《大众哲学》，这本看完了，高中朋友们推荐的哲学读物；第三年是《霍金讲演录》，霍金是我一直景仰的人，很喜欢他的著作，最近在看他的《霍金十问》；今年买的是《The Complete Fiction of H.P. Lovecraft》，纯英文的，厚厚一本像本字典，收录了洛夫克拉夫特的小说作品，虽然还没怎么看，但将来必要通读一遍。这个目标希望我能坚持下去，也算是我为数不多的年度计划吧。\n知识与技能 编程 大学期间获取最多且提升最大的就是编程相关的知识和能力了。自从大一下学完C/C++后，便基本完成了启蒙，然后因为想用cocos creator做做游戏，开始学习JavaScript，后来注意到JS更多应用在网页，开始了解Web开发，然后延伸到前端与后端的概念，开始了解和学习相关的知识，包括前端的框架（主要学习了Vue2，后面发布了Vue3也在跟进）以及后端相关的服务器（开始主要是学习使用Node.js）与数据库（主要是NoSQL的MongoDB）。后来更加横向扩展知识面，开始学习Golang、Rust这些新的语言，去扩展TypeScript方面的知识，考计算机二级，学了Python。后来又在使用Godot做游戏，又得学习GDScript。 但是，问题很大的出在缺少代码量上，总是不能很持久地去学好一门编程语言，然后就是学后缺乏实战，很多知识流失得很快。\n英语 大一过的四级，大二过的六级，然后一直颓废，准备考研才又拾起来，现在的英语能力顶多看看某英国熊猫人VTuber的直播，阅读理解能力逐年下降，词汇量捉摸不定。 不过还是时不时保留一定量的英语使用，因为一些开源项目的文档、工具的文档需要。但是词汇是个大问题。\n小语种 日语已经常年停滞，但是摄入量很大，不时看日语动画、视频、直播，会去关注一些语言学及方言的东西，偶尔研究关西腔的发音特点。有时也会突然来感觉，然后抄抄日语歌词，现在日语歌词加上高中时的量，已经接近两本。 德语自从二外课之后就很少再捡起来，虽然词汇量和语法不行，但发音规则还记得一些，难能可贵的是，数字一到十说地贼溜。\n游戏开发 Godot在学，目前在写敌人寻路算法，用的Dijistra。 Aseprite在学，像素绘画是个难题。 Fruit在学，编曲前可能得学基础乐理。\n成就 （虽然少得可怜）\n英语四级、六级 计算机二级 校级力学创新实验大赛三等奖 好吧，大学摆了两年，该学了。。。\n","permalink":"https://akashiya-chime.github.io/posts/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/","summary":"\u003cp\u003e大学啊。眨眼就过去了呢……\u003c/p\u003e","title":"我的大学"},{"content":"总是喜欢玩玩各种各样的工具软件，逐渐的工具就积累下来了，有的适合自己就在使用，有的工具被更适合自己的替代，有的不适合的又卸载了。想着能不能做一些总结，当别人需要的时候能够更好地去推荐，帮他/她找到适合自己的那一个。总之，先试试汇总一些笔记软件。\n前言 一向认为工具推荐不应强加推荐指数，一来是因为我觉得工具与人的贴和程度才是评判好用与否的指标，二来是怕引起争执。 本篇重点在笔记软件，也就是突出软件记录、帮助思考和整理知识的功能。（但我不保证不会偏题） 一直很喜欢Topbook的一句话：\n「让工具成为工具，让你成为你」\nnotion markdown：支持部分 特点：块体系、方便的云存储、团队编辑、支持网页编辑、template 官网：https://www.notion.so/ notion算是我接触最早也是到目前用地最多的一个笔记软件。由于是突出「块」这个概念，所以并不怎么要求你写markdown，块单元都可用 / 来生成。像什么分级标题、无序列表、有序列表、代码块这些基本的，亦或者page、table、board这种复合式的块都能生成。\n界面也算比较美观，左侧管理你的工作空间、设置、大纲等，可能大多数人认为缺点在没有中文\n插曲：搞了一小时解决archlinux上传图片到图床问题。原本的逻辑是picgo传github用CDN(jsDelivr)加快加载速度，然后想换成gitee，结果发现picgo failed to connect proxy，查github issue无果，后转utools的图床插件，发现配置后正常上传，但是正常使用我得把仓库变成公开的。。。\nnotion还能嵌入一些诸如网页、视频、文件、Tweet甚至是Figma、Excalidraw等等可以通过链接访问的块，虽然优化欠佳，但胜在它有这功能。\n如果你觉得自己编辑的页面太过简单乏味，或者不知道如何开始就把页面占满，你可以到Template里找找你喜欢的模板。\n我使用notion主要是用于一些合作性的编辑。比如室友之间共享同步一些在线看视频的网站，或者搞项目的时候管理项目进度，记录项目讨论内容等。\n感受上的缺点在于，因为服务器在国外，页面加载速度不太行，特别是登陆的时候。另外，我使用期间对于收费有一次更新，原来的notion是个人空间和团队空间都是限定了「块」的数量的，超了就pay，要么再建一个空间。后面更新后，个人空间完全免费了（虽然我感觉团队空间变小了）。\nwolai markdown：支持部分 特点：中文版notion 官网：https://www.wolai.com/ 但凡有notion替代品推荐或者类似推问的时候，只听见下面有一个「我来」，这时候，我一看，人群中钻出来一个光头。（咳咳，别打脸）\n总之各个方面都和notion差不多，区别就在国内服务器，国内团队开发，中文，有人和你一起吹它nb。但这玩意儿也不是完全免费的，甚至还有积分制，拉人给积分换专业版。\n但是wolai的团队空间目前块数量是无限的，而且感觉功能比个人免费版还要支持得多一点，这点还是蛮香的。\n我最开始去体验的时候还只有网页版，现在也能支持桌面端和移动端了，希望发展越来越好吧。\nflomo markdown：不支持（感觉也没太大必要） 特点：微信写入、想到啥写啥、简洁 官网：https://flomoapp.com/ 「flomo浮墨笔记」想去推崇这样一种随想随记的一种理念，官方没有很着重怎么去用它，而是把这个问题交给用户。你可能会关注公众号之后陷入长期的思考，想想自己拿这玩意儿干什么。\n但是对于我来说，我感觉它更像是一个可以同步的便签，优点在于移动端记起来很方面。因为它太简单了，所以你不用去考虑排版啥的。\n由于大多用户存文字，官方压力小，所以免费版给了无限的文字量和500MB的图片。PRO版最吸引我的是开放的API，我可以通过utools或者别的一些应用来将我的思考或者想法发到flomo。\nlogseq markdown：完全支持 特点：双向链接、插件、想到啥写啥、开源 官网：https://logseq.com/ 前段时间了解到，前两天才开始用。因为不是很理解「双向链接」的理念，所以上手总感觉怪怪的。\nlogseq也是和flomo一样推崇想到啥记啥，不要让你的才思被如何排版美观给耽误了。不像notion或者别的一些笔记软件（以一个一个的笔记为单元），logseq更像是在写日记（Journals），它会自动生成以当天日期为题的页面，你只需要把你的想法记在这个页面，不用去寻找这个想法归属于哪个类，这个笔记应该放在哪个文件夹下，打开软件就是写，别的事情交给双向链接。每个双向链接都是一个单独的页面，页面里可以记录内容，也可以看到哪里引用了。\n我觉得这个软件很好的一点在于，你可以把鼠标放在双向链接上就能对该链接的内容有一个预览，甚至是修改里面的内容，这个我很喜欢。\n当然，我也有一些用不惯的地方。比如链接之间的跳转，由于没有笔记本的束缚，所以很有可能跳转几次之后不能很快回到你想回到的位置。另外就是，我不知道怎么搜索当前页面的内容。\n软件提供的搜索只能够搜索双向链接，但是对于页面内的文字却不能检索，这一点，很难受。\n但我还是在努力地使用这个软件，因为我想要尝试这样的一种无需去关注笔记放在哪里的理念。因为我一直都是对归类整理很下功夫的性格，虽然有了一些心得，但是我也很清楚它带给我的工作量的增加与思考上的开销。\n软件开源，你完全可以在开源协议下自行摸索，如果就单纯想改改样式，软件也为你提供了css接口。当然，如果你嫌自己配置麻烦，软件也支持插件、主题，你可以试试能否找到你心仪的一个。但是需要说的一点，安装插件和主题的资源来自github，所以不能科学上网可能会安装失败或者缓慢。\n笔记保存在本地，当然，你也可以通过git放到远端仓库。\ntypora markdown：完全支持 特点：简洁、自定义、1.0收费 官网：https://www.typora.net/ 在程序员间广为流传的软件，与其叫做笔记软件，其实就是一款markdown编辑器。但是呢，它度过了漫长的beta期，正式发布了1.0版本，并开启了付费时代。\n正如官网所言「简单但强大」。打开软件，新建一个文件.md，然后就可以愉快地开始你的markdwon编辑。软件实时渲染markdown，让你的格式所见即所得。如果你觉得自带的样式不好看，也可以去社区找到你喜欢的一款。\n这也是我用过很久的一个应用，之前的Blog也是用它写就，虽然官方说1.0以前的版本仍然免费，但我总感觉少了点什么，导致我和它渐行渐远了。\nobsidian markdwon：完全支持 特点：双向链接、插件 官网：https://obsidian.md/ 让我最早接触到双向链接的软件。虽然到现在我也没用它创建过多少双向链接。\n我更多还是大才小用，拿它当作一个简单的markdown编辑器，拿它替代typora来写一些需要markdwon的东西，比如，Blog。之前也拿它做毕设需要的万字英文翻译。\n但是我怎么用并不代表它就只能这么用。「obsidian黑曜石」是一个非常不错的双向链接笔记软件，类似于typora的文件组织思路以及所见即所得的功能让用户更容易上手写东西。\n丰富的插件库让你得到与别的用户不一样的适合自己的写作体验。\n双向链接是它主打的特色，你可能第一眼就会被官网图片的关系图谱所打动：\n也许当我理解了双向链接，我会更喜欢拿它来记一些东西。\nzettlr markdown：完全支持 特点：Linux支持得不太好 官网：https://www.zettlr.com/ 之前typora收费的时候，大家开始寻找替代品，所以每天看到一大堆推荐，这就是其中一个。\n但是呢，之前用着感觉还行，但是我刚才打开它，它卡死了。。。\n如果你欣赏它的界面风格，而且又不在Linux下使用的话，可以尝试一下，虽然它的体积不小（Linux下有300MB+）。\njoplin markdown：完全支持 特点：简洁、传统、开源 官网：https://joplinapp.org/ 这也是和zettlr同样的来源。\n虽然我更喜欢所见即所得的markdown写作（也是我不用vim编辑markdown的主要原因），但是这个软件其实看上去还行，挺简洁的，虽然有有个突兀的菜单栏。传统的左边编辑右边渲染的设计有时候也挺不错。\n文件夹作为笔记本，里面的markdown文件就是一份一份的笔记，清晰简洁，就是竖栏太多，感觉有点挤，或者空间有点少（虽然可以通过快捷键关闭左边的笔记本栏）。\n它也支持插件和外观自定义，但是打开的时候重新渲染会有点慢，感觉有点别扭。\njrnl markdwon：冇 特点：终端下的日记本 官网：https://jrnl.sh/en/stable/（没想到它还能有个官网） 就同上面特点介绍的，这其实就是个终端下的日记本。\n为什么要说他是一个笔记软件呢，主要是在Linux下工作，总想着什么事情能不能都在终端下完成。jrnl就是这样的一个终端应用。\n你只需要在终端下打 jrnl 然后后面就是你要记录的东西了，它会以日期的形式记录下来（实际上就是写到一个txt里面）。然后可以用比如 -from -to 之类的参数来查看你的笔记，甚至是加一些tag。\n它实在是太过于简洁了，以至于你自己都能实现一个，甚至做出更贴和自己习惯的样子，所以，这可能只是一个启发或者例子。\n总结 以上，大概介绍了我想介绍的我用过的一些笔记软件。我时常在想，我是否缺的并不是笔记工具，而是缺一个真正想坐下来记笔记和写作的心。所以「让工具成为工具，让你成为你」触动了我。\n","permalink":"https://akashiya-chime.github.io/posts/%E7%94%A8%E8%BF%87%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/","summary":"\u003cp\u003e总是喜欢玩玩各种各样的工具软件，逐渐的工具就积累下来了，有的适合自己就在使用，有的工具被更适合自己的替代，有的不适合的又卸载了。想着能不能做一些总结，当别人需要的时候能够更好地去推荐，帮他/她找到适合自己的那一个。总之，先试试汇总一些笔记软件。\u003c/p\u003e","title":"用过的笔记软件汇总"},{"content":"上一个Blog已经是去年11月中旬的事了，然而这个Blog确是在隔一年的2月的中下旬。期间3个月，经历了全国统一研究生入学考试、参加了某互联网公司的招聘面试、完成毕设要求的万字引文文献翻译、尝试并行开发两个独立游戏等等。每个都值得单独写一篇Blog，但是为什么不呢，或许是我太懒了吧。。。然而马上就要开学了，开题报告还没有写完，游戏开发还没什么进度，核酸还没有做。就随便写点，做个小结，内容请参照目录。\n考研 与室友报了同一个学校的同一个专业，然而结果是他选择了大本钟，我选择了在大本钟下开快递，他负责摆，我负责寄（雾）。\n前期准备 一般来说，想要充分一点的时间可以提前一年开始准备，当上一届考完就可以开始看数学了，数学是考大多数理工科专业的核心。考研数学一150分、英语一100分、政治100分、专业课150分，总分500分，400分是个大门槛，400分对大多数211和少部分980学校理工科专业考研初试是很稳的一个分数（个人理解）。我最初的理想成绩至少是数学、专业课120分、英语、政治60分，这样就有360分，我所报考的专业的专业课是属于比较简单的那种，大家的成绩会比较高，甚至140+的不在少数，所以竞争力更多会放在数学。观察往年上线者的成绩，可见确实如此。所以，数学很重要，也很难，特别是数学一，内容会更多，越早准备越好。\n数学 按数学一说事，分高数、线代、概率统计。节奏一般来说就是跟老师学然后刷题，根据个人经验，高数一轮可以跟汤加凤，主要解决这个年龄怎么睡得着觉的问题，买讲义和《接力练习1800》，汤要求你1800要挨着做，不能跳，但我一战下来发现题量还是有点大的，而且很多题需要钻研，所以并未全做。高数强化建议武忠详，强化阶段的主要任务是刷题，主要解决经典的错误、标准的零分。我的线代和概率统计都是跟的汤，所以这里建议绝对不要学我，汤的线代还将就能听，但概率统计真的不太行（个人观点），其中，三大计算可以尝试杨超，室友做了三遍，相信不会差（笑）。线代可以试试张宇，虽然各室友评价褒贬不一，但我觉得他的线代还是挺不错的。但是大一一来就听到李永乐老师在线代上的大名，但我确实没有尝试过，只知道复习全书很厚。概率论没有推荐，但是内容和分值也不算特别多，只是要避开汤的坑。\n英语 都在讨论跟什么老师，但我觉得英语就是单词和做题，贵在坚持和积累，在积累中总结技巧，所以没必要说得跟个什么老师。我的节奏是每天一定量的单词，然后一篇完型一篇阅读，然后临考开始做真题，作文确有练习的必要，但我确实没有时间，毕竟，我负责寄。\n政治 直接徐涛强化版，买讲义跟着过一遍，辅助肖秀荣1000题，然后等肖四肖八，拿到手就开背。\n专业课 我是跨考的，所以专业课得我这种非科班人是难点和重点，虽然对我来说，我选择跨考单纯是认清了我不管是考本专业还是跨考，专业课都是从零开始，所以没有太大区别。对于跨考生，专业课应尽早开始学，特别是408。408有四门，计网、计组、数据结构与算法、操作系统。计网需要理解记忆，计组和操作系统要背，数据结构与算法少但很难，题型多样。数据结构与算法不仅是考研的科目，还是计算机相关行业求职的考察重点，下文应该还会提到。 一般学校会给出相应专业课的推荐书籍，可以借鉴，也可淘宝寻找辅助书籍，尤其是真题。节奏一般就是学习、刷题、背，但是你需要认清是否是拿分核心的部分。\n考试 报名时注意是否可以预报名，有的地区只有一战可以预报名，有的地方不限，预报名很重要，是要抢位置的。离你近的考点报满了你就只能选更远的考点。然后就是需要知道是否需要选校区，很多大学是要分校区的，虽然你报了这个学校的考点，但还需要过一段时间在学校官网选校区。 考研持续两天，所以如果考点报的远，要提前做好酒店的预约（酒店一定要考究一下，贵一点也没事，反正就两三天，我和室友就遭了罪，小旅馆条件极差，还好我们只住了一晚）。 考完啊，考完就可以浪了（不是）。一般考研初试成绩在2月底公布，比如我这个点，明天查成绩，如果你上线了，一般在3月底4月初进行复试，所以如果你没有必挂的决心，请一定提前了解专业复试科目和复试形式并在考完初试就立即进入复试的准备。\n总结 我是认定自己初试过不了了，客观原因在于本专业确实忙，总共要修180+的学分，主观原因确实是中后期成天摆烂。但是已有二战的打算（毕竟努力百日报考维也纳艺术学院，考不上就二战），进况后面跟进，只能说自己加油吧。\n某互联网公司面试 原因主要是想体验一下招聘面试的流程。\n是在考研途中进行的，到现在已经忘了很多了。该公司在面试前经历了好多步骤，先是投简历，简历是用该公司自定义的简历，你需要填他们需要知道的（但这个公司很看重在公司里是否有你的亲属）。 然后开始进行一个类似问卷一样的，称作主观题，有各种神奇的问题，诸如：\n你认为这世界中各种事物，公平吗？ 你是否希望中国人多生孩子？ 这是一个周六，你原计划周日去健身房跑步1小时，再去江边散散步。你的直属上级的直属上级主管，要你明天去他家领个包裹，亲自开车2小时送到某地点交给指定的人，你会如何做？ 你怎么看待现在的动物园把熊猫关在笼子里？ 如果你家所居住的居民小区，物业规定严格完全禁止养宠物狗，你怎么看？ 请问至今为止，你大概累积看过多少本课外书？其中主要有哪些类型的书，分别大概多少比例？其中你最喜欢的书是什么？哪句话你最喜欢？ 你童年时期和少年时期主要是和谁在一起生活？你对他们是如何评价？你最欣赏的亲人是谁？为什么？ 军人的第一天职是什么？为什么这样？你觉得工作生活中应该这样吗？请用300字以上内容回答 请用至少300字，描述和评价你的父亲。 你最喜欢的偶像或明星是哪些？为什么？ 你有亲兄弟姐妹吗？是哥哥姐姐，还是弟弟妹妹？ 假如中国没有限制生育，你希望你父母在你小时候生几个孩子。 等等。\n但是显然不是重点。\n之后是在线笔试，该公司要求使用他们的软件（害得我装双系统加一个Windows），题型各种各样，包含但不限于408中的各项和数据库，当然也包含一定的编程题，但是是算法题。做下来我深知不能过，大多数题都是我知识以外的东西。\n笔试完我等了半个多月，然后他们提示我说居然让我面试。第一次面试还是很紧张的，开始结结巴巴的，有时候逻辑挺混乱的。\n开始是自我介绍，介绍还是不要太短，讲讲兴趣爱好，然后问了问为什么不选择干本行而是跨专业，会有编程题，发回伪代码或者口述思路，以下是我的考题：\n1 2 3 4 5 给定一个集合S(没有重复元素), 输出它所有的子集 输入 1 2 3 输出 1, 2, 12, 3, 13, 23, 123 实现一个整形转中文的函数. 输入: 10023450 输出: 一千零二万三千四百五十 要求: 1. 可用中文\u0026#34;个\u0026#34;,\u0026#34;十\u0026#34;,\u0026#34;百\u0026#34;,\u0026#34;千\u0026#34;,\u0026#34;万\u0026#34;,\u0026#34;亿\u0026#34;,\u0026#34;兆\u0026#34;,\u0026#34;零\u0026#34;,\u0026#34;负\u0026#34; 2. 最大支持百兆 1,000,000,000,000,000 ^ ^ ^ 兆 亿 万 给定一个二叉树，对于每个节点的子节点互换左右位置 会问做过的一些项目，会问是否有两个人一起做过的一些项目，会问编程语言方面的一些问题（python中is和 == 有什么区别）最后问你有没有什么想问的。\n结论就是，加强数据结构和算法的学习，很重要。\n独立游戏开发 终于到我坠喜欢勒环节咯。开发独立游戏是在考研第二天下午决定的，因为想到了一个似乎可行的游戏机制，然后就想网络人来做，但是路途却十分坎坷。\n启动阶段 找了有共同爱好的好朋友，说了游戏机制怎么怎么好玩，然后开始画饼。结果是开了两个项目，每个项目两个人，一个是做横版2D像素地下城游戏，一个是做俯视角（顶视角）2D像素射击游戏。 初期是使用Godot引擎进行游戏开发，使用石墨文档做文档整理，使用notion做项目进度规划，用开黑啦开会。\n初期 初期干的事情主要是游戏设计，也就是写GDD（Game Design Document），放在石墨里，参照了尚在天国的从零开始做游戏！第一课！【天国的游戏设计教室Vol1】。包含了游戏的介绍、背景等基础的东西也包含了游戏机制、UI、关卡等细致的东西，前前后后讨论近一周，并在后期开发中不断完善。我在开发途中也在看图书馆借的《通关！游戏设计之道》，该书讲解生动有趣，确实是游戏设计的良好读物。\n开发期 独立游戏开发，离不开游戏引擎、美术和音乐。\n游戏引擎 我们使用Godot作为游戏引擎进行开发，Godot开源免费，体积小，跨平台，开发方便，引擎本身是C++做出来的，所以运行速度是很快的。Godot自己开发了一种叫GDScript的编程语言用以使用者编写游戏脚本，该语言与Python极其相像，所以上手并不困难。Godot的官方文档虽有中文，但汉化十不足一二（但是最近看b站某团队在众筹翻译），文档中有个类似Cocos Creator的First Game实战，可以跟着做一做以熟悉引擎。 项目初期，大家都是从零开始，所以大多时间都是在学习，学习引擎的使用，包括各种关于像素游戏的项目设置、各种节点的用法，编程语言的使用等等。\n版本控制 因为是多人开发，免不了要同步项目进度以及进行版本控制避免不可挽回的错误。所以使用Git作为版本控制工具确实是种不错的选择。考虑到国内连接Github速度感人，而且游戏各种素材体积堆起来很大，所以我们将项目放在了国内的码云（Gitee），速度立马就上去了。对于使用Git，有一些东西可以分享。初期我是在Linux下进行游戏开发，所以使用lazygit作为Git工具，后面为了制作各种素材且方便同步，换到了Windows，虽然尝试过Windows装Linux子系统（装了个Arch）能够使用lazygit，但是子系统确实很占内存。前两天搜索了一下发现了gitui，号称比lazygit快很多：\n使用了一下，体验还行，于是开始使用gitui。\n像素绘画 由于开发2D像素游戏，所以像素素材怎么获取是个问题。目前是使用人工绘画，包括各种人物角色、场景、Tilesets。我们使用的是Aseprite，该工具专业画像素，使用方便。软件本身开源：aseprite，你可以下载自行编译，也可以在steam上购买得到。该软件很多地方和以前用过的flash很像，包括时间轴和洋葱皮都是我很喜欢的功能。 虽然工具高效可用，但是主要问题在于绘画基础。demo场景所需要的素材三四个星期没搞定（虽然我认为更多是我们懒造成的）。\n音乐 游戏音乐包括了BGM和游戏音效，但游戏音乐不是前期需要关注的重点，但是我还是进行了一些准备。我在引擎学习使用、像素绘画学习和素材准备期间，逐步开始学习一些乐理的知识，然后找到了编曲的软件：FL Studio，并且去找了一些可用的音源，比如LASS 2（21G）用来做弦乐。然后学习了交响乐中的各种乐器，包括比如\n弦乐（Strings）中的竖琴（harp）、小提琴（violin）、中提琴（viola）、大提琴（cello）、低音提琴（double bass）\n木管乐（Woodwinds）中的短笛（piccolo）、长笛（flute）、高音单簧管（E-falt clarinet）、单簧管（clarinet）、低音单簧管（bass clarinet）、双簧管（oboe）、巴松管（bassoon）、英国管（English horn）\n铜管乐（Brasses）中的圆号（法国号）（French horn）、小号（trumpet）、长号（trombone）、低音长号（bass trombone）、上低音号（悠风号）（次中音大号？）euphonium（tenor tuba）、大号（tube）\n以及各种打击乐（Precussion），比如定音鼓（timpani）、钢琴（piano）、军鼓（snare drum）等等。音乐真是个好东西啊\n于是对交响乐、吹奏乐、弦乐四重奏有了兴趣，希望能够作一些曲子出来作为游戏BGM。\n工具的升级 项目中途发现了字节跳动开发的飞书，体验后觉得不错，而且免费，于是从notion上转移过来，在飞书上做每日的汇报、每周开会、讨论开会、同步项目进度等都在飞书上进行。还有各种功能边用边发现。\n项目管理上的一些总结 虽然是合作开发，但共同的开发者似乎积极性不是很高，我不得不做了很多管理的工作，所以这里做一点管理上的总结。 怎样调动成员积极性是个老生常谈的问题，也确实是很难解决的问题，特别是在这样一个年假中，对于我们这种考研都没坚持下来的人确实让我们不懒是个问题。在其中一个项目的讨论中提到这个问题后给出的解决办法是每天固定时间签到，然后每日提交一份总结当日工作以及明日工作安排的日报，每周开例会总结工作以及安排项目。但是结果并不乐观，每日的签到安排在早八，但没几天是起来签了到的，日报虽然每日按要求在交，但质量参差不齐，每周例会非常被动，或者说没有内容可讲，主要是我在提问，然后收到什么都没做的回答。 作为初学者，开发者面临更多的问题在于如何开始，以及如何开始学习。在像素绘画方面体现出来的问题，成员会因为找不到学习方法而踌躇止步。这个时候同样作为初学者，如何帮助成员而不是一味给成员指路（因为你也不知道路应该如何走才是正确的）成为一个应该思考的问题。如何劝导成员自己寻找学习方法来提高自己水平到现在仍然是我研究的问题。 另外可以看到的一个问题在于交流的缺乏。我们的成员都比较被动，不愿意主动交流学习和开发上遇到的技巧和问题。我每次开例会都会去问本周的工作是否遇到了什么问题，成员对目前项目进度有什么问题，对于目前项目进行慢有什么看法等，非常的被动。我认为这点还是需要一点榜样作用以及更多的是个人的自觉。当所做的工作多起来，才能遇到各种问题，没有问题说的主要原因可能在于做的工作量不够，所以问题又回到如何调动成员积极性上来。\n以上，就是懒惰多月后的一次复健，望开学后能够对今后的规划能思考地更加透彻。 そして、つきの曲が始まるのです。\n","permalink":"https://akashiya-chime.github.io/posts/%E5%81%87%E6%9C%9F%E6%80%BB%E7%BB%933/","summary":"\u003cp\u003e上一个Blog已经是去年11月中旬的事了，然而这个Blog确是在隔一年的2月的中下旬。期间3个月，经历了全国统一研究生入学考试、参加了某互联网公司的招聘面试、完成毕设要求的万字引文文献翻译、尝试并行开发两个独立游戏等等。每个都值得单独写一篇Blog，但是为什么不呢，或许是我太懒了吧。。。然而马上就要开学了，开题报告还没有写完，游戏开发还没什么进度，核酸还没有做。就随便写点，做个小结，内容请参照目录。\u003c/p\u003e","title":"假期总结（3）"},{"content":"Vim 作为一款高自由度的文本编辑器，广受众大佬的喜爱，然而高自由度另一方面带来的繁琐纷杂的配置劝退了 80% 的尝试者（像极了 DND 传教时玩家被 200 多页的玩家手册劝退）。但是呢，当你配置到位了，熟悉了 Vim 的快捷操作，它会回报你，它的开发效率可能会超过任何一个你使用过的 IDE。\n做一些说明 使用 Vim 的缘由 其实我一向是 VSCode 的拥护者，VSCode 的确给了我很好的编程体验，但是呢，某些时候会让我感到难受。在写 Go 的时候，会去装巨硬官方提供的扩展:\n但是，它会带来各种各样的问题，先是 gotools 安装失败，然后找个各种办法去解决，然后，最新的扩展跟新了改为 gopls（Go Language Server Protocol） 来处理 go，它要求你每个 module 需要在一个 VSCode 的 workplace 下，不然就会报以下的一个错：\n1 2 3 4 gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder. Improvements to this workflow will be coming soon, and you can learn more here: https://github.com/golang/tools/blob/master/gopls/doc/workspace.md. 很难受，网上最多的方法就是在 setting.json 中设置：\n1 2 3 \u0026#34;gopls\u0026#34;: { \u0026#34;experimentalWorkspaceModule\u0026#34;: true } 但是我设置之后会导致鼠标放置提示消失，总之就是非常难受。\n然后呢，想继续开发一下自己使用 Vim 的能力，于是就试试专门用 Vim 来做 Go 的 IDE 来试试。\n关于配置 本篇文章全部配置是我个人使用的配置，并没有涵盖所有的配置\n我的配置已经上传到 Github，不过没什么注释，下面我会进行比较详细的注解，尽量保证没一行配置都能知道干了什么\n每个代码段的第一行注释注明了所修改的文件以及文件在我的（ArchLinux）系统中的绝对位置，可以作为参考（其实可能也就只有 .vimrc （vim run commands，也有说 run control 的）文件需要修改）\nWindows 的用户，可以在 Vim 中使用 :version 查看系统或者用户 .vimrc 文件位置\n基础操作 在写配置之前，需要一些基础的 Vim 操作知识\n模式：Vim 具有 NORMAL、INSERT、VISUAL 三个模式\nNORMAL：命令模式，在这个模式下使用命令\nINSERT：输入模式，这个模式下打字\nVISUAL：可视模式，这个模式下进行文本操作，比如复制、剪切等\n基础命令\n:w 写入，:q 退出，组合起来就是喜闻乐见的常用的保存并退出 :wq h 左，l 右，j 上，k 下 w word，移动到下一个单词开头 b before，移动到上一个单词开头 e end，移动到下一个单词结尾 a append，在光标后进入 INSERT 模式，A 在光标所在行的末尾进入 INSERT 模式 i insert，在光标处进入 INSERT 模式，I 在光标所在行的开头进入 INSERT 模式 o 在光标下插入一行进入 INSERT 模式 yy 复制光标所在行 dd 剪切光标所在行 p 粘贴 gg 跳到第一行 G 跳到最后一行 u undo，撤销 Ctrl+r redo，把撤销的步骤撤销回来 v 进入 VISUAL 模式 \u0026lt;ESC\u0026gt; 退出当前的 INSERT 或 VISUAL 模式，进入 NORMAL 模式 \u0026gt;\u0026gt; 增加一级缩进，\u0026lt;\u0026lt; 取消一级缩进，== 取消全部缩进 查询\n/ 查询 回车后，使用 n next 和 l last 来上下跳转筛选项目 基础配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026#34; ~/.vimrc \u0026#34; 打开高亮 syntax on \u0026#34; 打开行号 set number \u0026#34; 光标所在行高亮 set cursorline \u0026#34; 在底部显示键入的指令 set showcmd \u0026#34; 命令模式用 Tab 自动补全 set wildmenu \u0026#34; 高亮搜索匹配结果 set hlsearch \u0026#34; 去掉高亮（感觉有点玄学） exec \u0026#34;nohlsearch\u0026#34; \u0026#34; 边输入边高亮 set incsearch \u0026#34; 忽略大小写 set ignorecase \u0026#34; 只能大小写（其实就是只对第一个字母大写的搜索词大小写敏感） set smartcase \u0026#34; 自动缩进，回车后下一行的缩进与上一行的缩进保持一致 set autoindent \u0026#34; 智能缩进 set smartindent \u0026#34; 一个 Tab 缩进 4 个字符 set tabstop=4 \u0026#34; 增加或取消一级缩进时的字符数，建议与缩进保持一致 set shiftwidth=4 \u0026#34; 由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格 set expandtab \u0026#34; 智能缩进，根据文件其他地方的缩进来确定一个 Tab 多少缩进 set smarttab \u0026#34; Tab 转换为 2 个空格 set softtabstop=2 \u0026#34; 支持鼠标（虽然但是，“我们是为了解放鼠标才来用 Vim 的！”） set mouse=a \u0026#34; 状态栏现实光标当前位置（哪行哪列） set ruler \u0026#34; 设置 utf-8 编码 set encoding=UTF-8 \u0026#34; 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示 set laststatus=2 进阶配置 这个地方的配置是更加个性化的配置，我会讲解部分个性化配置的方法，并且给出我的部分个性化配置以做参考\n首先得搞清楚一些缩写或者字符串所代表的含义\n标识符号 代表含义 \u0026lt;Esc\u0026gt;代表 Escape 键 \u0026lt;CR\u0026gt; 代表 Enter 键 \u0026lt;C-Esc\u0026gt; 代表 Ctrl-Esc \u0026lt;S-F1\u0026gt; 表示 Shift-F1 \u0026lt;D\u0026gt; 代表 Command 键，对于 Mac 用户，可以使用 \u0026lt;M-key\u0026gt; 或 \u0026lt;A-key\u0026gt; 代表 Alt 键 \u0026lt;leader\u0026gt; leader 键，默认是反斜杠 \\，很多人喜欢改成空格\n\u0026lt;C-r\u0026gt; ：Ctrl + r\n\u0026lt;CR\u0026gt; 回车，或者叫 Enter\nmap 是 Vim 配置中的处理映射的关键字，在它的前面可以加一些不同的前缀来体现一些特殊含义，如下表：\n前缀 含义 nore 非递归 n NORMAL 模式生效 v VISUAL 模式生效 i INSERT 模式生效 c 命令行模式生效 un 后面跟组合键，表示删除这个映射 clear 清除相关模式下所有映射 1 2 3 \u0026#34; ~/.vimrc \u0026#34; 设置 leader 键，默认反斜杠 \\ let mapleader=\u0026#34; \u0026#34; \u0026#34; 或者转义一下，\\\u0026lt;space\u0026gt; 通常我们在对 .vimrc 文件进行修改后，需要 :wq 保存退出再重新进到 Vim 中才能看到我们的修改生效，但其实可以通过同 Linux 的 source 一样的方式来重新读取配置文件来快速“刷新”，例如以下配置：\n1 2 3 \u0026#34; ~/.vimrc \u0026#34; 使用 R 来输入命令 :source $MYVIMRC，并在最后回车执行 map R :source $MYVIMRC\u0026lt;CR\u0026gt; 我们可以看到 map 的用法很简单，就是用后面接的第一个字符来表示后面的字符或命令。\n这里再推荐一些我的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34; ~/.vimrc \u0026#34; 使用 \u0026lt;leader\u0026gt;w 来完成保存 nmap \u0026lt;leader\u0026gt;w :w\u0026lt;CR\u0026gt; \u0026#34; 使用 \u0026lt;leader\u0026gt;q 来完成退出 nmap \u0026lt;leader\u0026gt;q :q\u0026lt;CR\u0026gt; \u0026#34; 使用 J 来实现光标向下跳转 5 行 noremap J 5j \u0026#34; 使用 K 来实现光标向上跳转 5 行 noremap K 5k \u0026#34; 使用 H 来实现光标到行首 noremap H ^ \u0026#34; 使用 L 来实现光标到行末 noremap L $ \u0026#34; 使用 \u0026lt;leader\u0026gt; 回车来关闭搜索时留下的高亮（这个要靠谱点） noremap \u0026lt;leader\u0026gt;\u0026lt;CR\u0026gt; :nohlsearch\u0026lt;CR\u0026gt; 以上，我关于原生的配置就了解的差不多了，这些都比较的简单，你可以查询 Vim 官方的相关文档找到更多更详尽的配置条目和更高级的配置方法。\n插件 Vim 的插件生态也是 Vim 兴盛的必不可少也是情理之中的特点，插件的存在让我们不用重复地造轮子，又因其高自由度和开源，你甚至可以在别人的轮子上修改出自己舒适的形状，他就像 VSCode 的扩展一样让人感到亲切。\n插件管理器 安装 Vim 插件的方式很多，最原生的方式就是将插件的仓库 clone 下来，然后将插件文件丢到 .vim 文件夹下。但是呢，这样不够优雅。为了方便日后的插件管理，我们应当想到并使用插件管理工具\nVim 的插件管理器数不胜数，你甚至可以自己写一个，比较流行的，比如 Vundle，很多插件推荐或者教程都会使用 Vundle 的插件安装方式\n这里介绍另一个，也是我使用的，叫 vim-plug，简洁，易用\nvim-plug: GitHub - junegunn/vim-plug: Minimalist Vim Plugin Manager\n安装 vim-plug：\nGitHub 上给出了很多自动化，不同操作系统的命令行代码，比如：\n1 2 $ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 实际上操作就是将该仓库下的 plug.vim 文件下载下来放到 ~/.vim/autoload/ 目录下，如果你用 curl 用地不爽，你完全可以手动操作（plug.vim 文件）\n使用 vim-plug：\n我们回到 ~/.vimrc 文件，使用 vim-plug 很简单，我们需要将插件仓库包裹在 plug 代码块间，如下：（以下的就是我已经安装的插件，后文我会介绍）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026#34; ~/.vimrc \u0026#34; === \u0026#34; === vim-plug \u0026#34; === call plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;connorholyday/vim-snazzy\u0026#39; Plug \u0026#39;preservim/nerdtree\u0026#39; Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;release\u0026#39;} Plug \u0026#39;fatih/vim-go\u0026#39;, { \u0026#39;do\u0026#39;: \u0026#39;:GoUpdateBinaries\u0026#39; } Plug \u0026#39;dracula/vim\u0026#39;, { \u0026#39;as\u0026#39;: \u0026#39;dracula\u0026#39; } Plug \u0026#39;Yggdroot/indentLine\u0026#39; Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;jiangmiao/auto-pairs\u0026#39; Plug \u0026#39;preservim/nerdcommenter\u0026#39; Plug \u0026#39;ryanoasis/vim-devicons\u0026#39; Plug \u0026#39;tiagofumo/vim-nerdtree-syntax-highlight\u0026#39; Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39; call plug#end() 然后我们用用前面配置的方法，\u0026lt;leader\u0026gt;w 保存，然后 R “刷新”一下\n之后我们使用命令 :PlugInstall 来安装插件（速度慢问题见下一点）\n解决速度慢问题：\n首先得清楚为什么会慢，那当然是因为它是从 Github 下载的，会遇到墙之巨人，怎么解决呢，可以考虑使用镜像源，比如 fastgit\n可以参考一下文章：\nVIM-Plug安装插件时，频繁更新失败，或报端口443被拒绝等_htx1020的博客-CSDN博客\n简单来说就是更改刚下下载下来的 ~/.vim/autoload/plug.vim 中的\n1 let fmt = get(g:, \u0026#39;plug_url_format\u0026#39;, \u0026#39;https://git::@github.com/%s.git\u0026#39;) 改为：\n1 let fmt = get(g:, \u0026#39;plug_url_format\u0026#39;, \u0026#39;https://git::@hub.fastgit.org/%s.git\u0026#39;) 将：\n1 \\ \u0026#39;^https://git::@github\\.com\u0026#39;, \u0026#39;https://github.com\u0026#39;, \u0026#39;\u0026#39;) 改为：\n1 \\ \u0026#39;^https://git::@hub.fastgit\\.org\u0026#39;, \u0026#39;https://hub.fastgit.org\u0026#39;, \u0026#39;\u0026#39;) vim-plug 的其他操作：\n:PlugInstall：安装插件\n:PlugUpdate：更新插件\n:PlugClean：删除不在配置列表的插件\n:PlugUpgrade：更新 vim-plug 自身\n:PlugStatus：检查插件状态\n:PlugDiff：用来插件回滚（版本回退）\nvim-plug 还有一些全局的配置，可以参考 Github 的仓库，这里不赘述\n那我们就来介绍一些好用的插件\nvim-airline [vim-airline](GitHub - vim-airline/vim-airline: lean \u0026amp; mean status/tabline for vim that\u0026rsquo;s light as air)\nVim 最下方的一个横条，分了 A、B、C、X、Y、Z 几个区，可以显示当前模式，配合 git 显示当前分支等等。总之就是非常好看，如图：\n可以配合使用 airline-themes 来使用不同主题\nvim-airline-themes\n我有如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34; ~/.vimrc \u0026#34; === \u0026#34; === vim-airline \u0026#34; === set laststatus=2 \u0026#34; 永远显示状态栏 let g:airline_powerline_fonts = 1 \u0026#34; 支持 powerline 字体 let g:airline#extensions#tabline#enabled = 1 \u0026#34; 显示窗口tab和buffer let g:airline_theme=\u0026#39;dracula\u0026#39; if !exists(\u0026#39;g:airline_symbols\u0026#39;) let g:airline_symbols = {} endif let g:airline_left_sep = \u0026#39;▶\u0026#39; let g:airline_left_alt_sep = \u0026#39;❯\u0026#39; let g:airline_right_sep = \u0026#39;◀\u0026#39; let g:airline_right_alt_sep = \u0026#39;❮\u0026#39; let g:airline_symbols.linenr = \u0026#39;¶\u0026#39; Dracula dracula/vim\nDracula 主题的 Vim 版，配色还行偏粉紫，如图：\n在配置文件 ~/.vimrc 中添加\n1 2 \u0026#34; ~/.vimrc color dracula 来设置为 dracula\nNERDTree preservim/nerdtree\n文件树，配置和指令可参考 Github 的仓库，也可以在 nerdtree 下输入 ? 来取得帮助\n配合一些别的插件可以让 nerdtree 更好看一点，如：\nryanoasis/vim-devicons\ntiagofumo/vim-derdtree-syntax-highlight\nXuyuanp/nerdtree-git-plugin\n第一个是文件和文件夹的 icon，第二个是高亮，第三个是 git 插件\n我有以下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026#34; ~/.vimrc \u0026#34; === \u0026#34; === nerdtree \u0026#34; === nnoremap \u0026lt;C-n\u0026gt; :NERDTree\u0026lt;CR\u0026gt; \u0026#34;Show hide file. let g:NERDTreeHidden=0 \u0026#34;Delete help information at the top let NERDTreeMinimalUI=1 \u0026#34; === \u0026#34; === vim-devicons \u0026#34; === \u0026#34;Can be enabled or disabled let g:webdevicons_enable_nerdtree = 1 \u0026#34;whther or not to show the nerdtree brackets around flags let g:webdevicons_conceal_nerdtree_brackets = 1 \u0026#34;adding to vim-airline\u0026#39;s tabline let g:webdevicons_enable_airline_tabline = 1 \u0026#34;adding to vim-airline\u0026#39;s statusline let g:webdevicons_enable_airline_statusline = 1 \u0026#34; === \u0026#34; === vim-nerdtree-syntax-highlight \u0026#34; === \u0026#34;Highlight full name (not only icons). You need to add this if you don\u0026#39;t have vim-devicons and want highlight. let g:NERDTreeFileExtensionHighlightFullName = 1 let g:NERDTreeExactMatchHighlightFullName = 1 let g:NERDTreePatternMatchHighlightFullName = 1 \u0026#34;Highlight full name (not only icons). You need to add this if you don\u0026#39;t have vim-devicons and want highlight. let g:NERDTreeHighlightFolders = 1 \u0026#34;highlights the folder name let g:NERDTreeHighlightFoldersFullName = 1 \u0026#34;you can add these colors to your .vimrc to help customizing let s:brown = \u0026#34;905532\u0026#34; let s:aqua = \u0026#34;3AFFDB\u0026#34; let s:blue = \u0026#34;689FB6\u0026#34; let s:darkBlue = \u0026#34;44788E\u0026#34; let s:purple = \u0026#34;834F79\u0026#34; let s:lightPurple = \u0026#34;834F79\u0026#34; let s:red = \u0026#34;AE403F\u0026#34; let s:beige = \u0026#34;F5C06F\u0026#34; let s:yellow = \u0026#34;F09F17\u0026#34; let s:orange = \u0026#34;D4843E\u0026#34; let s:darkOrange = \u0026#34;F16529\u0026#34; let s:pink = \u0026#34;CB6F6F\u0026#34; let s:salmon = \u0026#34;EE6E73\u0026#34; let s:green = \u0026#34;8FAA54\u0026#34; let s:Turquoise = \u0026#34;40E0D0\u0026#34; let s:lightGreen = \u0026#34;31B53E\u0026#34; let s:white = \u0026#34;FFFFFF\u0026#34; let s:rspec_red = \u0026#34;FE405F\u0026#34; let s:git_orange = \u0026#34;F54D27\u0026#34; let s:gray = \u0026#34;808A87\u0026#34; \u0026#34; === \u0026#34; === nerdtree-git-plugin \u0026#34; === let g:NERDTreeGitStatusUseNerdFonts = 1 let g:NERDTreeGitStatusShowIgnored = 1 let g:NERDTreeGitStatusIndicatorMapCustom = { \\ \u0026#34;Modified\u0026#34; : \u0026#34;✹\u0026#34;, \\ \u0026#34;Staged\u0026#34; : \u0026#34;✚\u0026#34;, \\ \u0026#34;Untracked\u0026#34; : \u0026#34;✭\u0026#34;, \\ \u0026#34;Renamed\u0026#34; : \u0026#34;➜\u0026#34;, \\ \u0026#34;Unmerged\u0026#34; : \u0026#34;═\u0026#34;, \\ \u0026#34;Deleted\u0026#34; : \u0026#34;✖\u0026#34;, \\ \u0026#34;Dirty\u0026#34; : \u0026#34;✗\u0026#34;, \\ \u0026#34;Clean\u0026#34; : \u0026#34;✔︎\u0026#34;, \\ \u0026#39;Ignored\u0026#39; : \u0026#39;☒\u0026#39;, \\ \u0026#34;Unknown\u0026#34; : \u0026#34;?\u0026#34; \\ } 配置玩后会有以下效果：\n注：你也许以后想装一个叫 vim-rainbow 的插件，这是一个彩色标注括号的插件，但它与 vim-devicon 不兼容，会导致文件夹被一对放括号包住，很难受。 indentLine Yggdroot/indentLine\n缩进线插件，但似乎对 Go 的支持不是很好，效果如图：\nvim-startify mhinz/vim-startify\nstart screen，开始界面，如图：\nauto-pairs jiangmiao/auto-pairs\n括号自动补全，简单，但是好用，而且智能\nNERDCommenter preservim/nerdcommenter\n注释插件，有常用操作：\n\u0026lt;leader\u0026gt;cc 注释当前行和选中行 \u0026lt;leader\u0026gt;cn 没有发现和\\cc有区别 \u0026lt;leader\u0026gt;c\u0026lt;space\u0026gt; 如果被选区域有部分被注释，则对被选区域执行取消注释操作，其它情况执行反转注释操作 \u0026lt;leader\u0026gt;cm 对被选区域用一对注释符进行注释，前面的注释对每一行都会添加注释 \u0026lt;leader\u0026gt;ci 执行反转注释操作，选中区域注释部分取消注释，非注释部分添加注释 \u0026lt;leader\u0026gt;cs 添加性感的注释，代码开头介绍部分通常使用该注释 \u0026lt;leader\u0026gt;cy 添加注释，并复制被添加注释的部分 \u0026lt;leader\u0026gt;c$ 注释当前光标到改行结尾的内容 \u0026lt;leader\u0026gt;cA 跳转到该行结尾添加注释，并进入编辑模式 \u0026lt;leader\u0026gt;ca 转换注释的方式，比如：/**/和// \u0026lt;leader\u0026gt;cl \\cb 左对齐和左右对其，左右对其主要针对/**/ \u0026lt;leader\u0026gt;cu 取消注释 我有如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026#34; ~/.vimrc \u0026#34; === \u0026#34; === nerdcommenter \u0026#34; === \u0026#34; Create default mappings let g:NERDCreateDefaultMappings = 1 \u0026#34; Add spaces after comment delimiters by default let g:NERDSpaceDelims = 1 \u0026#34; Use compact syntax for prettified multi-line comments let g:NERDCompactSexyComs = 1 \u0026#34; Align line-wise comment delimiters flush left instead of following code indentation let g:NERDDefaultAlign = \u0026#39;left\u0026#39; \u0026#34; Set a language to use its alternate delimiters by default let g:NERDAltDelims_java = 1 \u0026#34; Add your own custom formats or override the defaults let g:NERDCustomDelimiters = { \u0026#39;c\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;/**\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;*/\u0026#39; } } \u0026#34; Allow commenting and inverting empty lines (useful when commenting a region) let g:NERDCommentEmptyLines = 1 \u0026#34; Enable trimming of trailing whitespace when uncommenting let g:NERDTrimTrailingWhitespace = 1 \u0026#34; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines = 1 coc.nvim neoclide/coc.nvim\nMake your Vim/Neovim as smart as VSCode. (Conquer of Completion)\n最后放这里压轴，毕竟 coc 太强了（当然，这里不是 Call of Cthulhu）\ncoc 可以为我们带来什么呢，插件下的插件，你可以安装很多 coc 的插件来达到 VSCode 那样的体验，它提供了各种语言的 LSP（Language Server Protocol），让你在写不同语言时能够有良好的代码补全体验。\n也许，你得去看看它的 GitHub 仓库，进行更个性化的配置\n我的配置有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026#34; ~/.vimrc \u0026#34; === \u0026#34; === coc.nvim \u0026#34; === nnoremap tt :CocCommand explorer\u0026lt;CR\u0026gt; let g:coc_global_extensions = [\u0026#39;coc-json\u0026#39;, \u0026#39;coc-vimlsp\u0026#39;, \u0026#39;coc-go\u0026#39;] set encoding=utf-8 set updatetime=100 set shortmess+=c nmap \u0026lt;silent\u0026gt; [g \u0026lt;Plug\u0026gt;(coc-diagnostic-prev) nmap \u0026lt;silent\u0026gt; ]g \u0026lt;Plug\u0026gt;(coc-diagnostic-next) nmap \u0026lt;silent\u0026gt; \u0026lt;F12\u0026gt; \u0026lt;Plug\u0026gt;(coc-definition) nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition) nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation) nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references) xmap \u0026lt;leader\u0026gt;f \u0026lt;Plug\u0026gt;(coc-format-selected) nmap \u0026lt;leader\u0026gt;f \u0026lt;Plug\u0026gt;(coc-format-selected) autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;) if has(\u0026#34;nvim-0.5.0\u0026#34;) || has(\u0026#34;patch-8.1.1564\u0026#34;) set signcolumn=number else set signcolumn=yes endif inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; \\ pumvisible() ? \u0026#34;\\\u0026lt;C-n\u0026gt;\u0026#34; : \\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : \\ coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-p\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-h\u0026gt;\u0026#34; function! s:check_back_space() abort let col = col(\u0026#39;.\u0026#39;) - 1 return !col || getline(\u0026#39;.\u0026#39;)[col - 1] =~# \u0026#39;\\s\u0026#39; endfunction 参考 追随大佬的步伐，这里推荐一 up 主，可以说我的 vim 启蒙是从他那里来的：\n@TheCW\n你可以从这俩视频里看到他的 Vim 玩得多溜：\n【硬货】新时代最流行的编程语言？10分钟学会Golang基础\n用多线程给代码提速800% —— Golang高并发教程+实战\n他的 Vim 入门教学：上古神器Vim：从恶言相向到爱不释手 - 终极Vim教程01 - 带你配置属于你自己的最强IDE\n他的 coc 讲解：【硬货】让你的vim像vscode一样强大 —— coc.nvim终极指南\n","permalink":"https://akashiya-chime.github.io/posts/%E6%88%91%E7%9A%84-vim-%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003eVim 作为一款高自由度的文本编辑器，广受众大佬的喜爱，然而高自由度另一方面带来的繁琐纷杂的配置劝退了 80% 的尝试者（像极了 DND 传教时玩家被 200 多页的玩家手册劝退）。但是呢，当你配置到位了，熟悉了 Vim 的快捷操作，它会回报你，它的开发效率可能会超过任何一个你使用过的 IDE。\u003c/p\u003e","title":"我的 Vim 配置"},{"content":"在最近的一件开发活动上与室友的意见发生了分歧，在分歧的处理上，我竟然发现自己完全没有话语权，我认为的个人财产安全度缺失居然连屁都不是。我认为，我必须得从这件事上总结点教训。\n写作之前，先放下跑团群常驻的一个标语：\n理念冲突请保持优雅\n另外做一些声明：\n个人并不会在此事上做更多的努力（That’s in vain） 优雅永不过时 事件缘由 前一段时间，室友自费购买硬件并开发了一个宿舍使用的开门系统，旨在为“开门”这一事件带来便捷。初衷是因发现宿舍来人比较频繁需要频繁起身去开门，而产生坐着就能把门开了的想法，最后做了这个系统（好笑的是，经过这几天的使用，我发现我们还是会选择起身去开门）。\n室友将项目开源放到 Github 上了，有意者可见：https://github.com/kakasearch/open_door\n在做成此系统后，为便捷另外两个室友，我向室友请求了 API，并将开门功能添加给了 QQ 机器人，使我们能够直接在宿舍群或私聊机器人发送“开门”指令而达到开门的效果。\n系统做成后室友一直觉得人要进屋，如果发送开门的时间掌握不好，会造成提前发送指令开门后，人还未到门前门就已经关闭的情况，就不得不再发一次指令，产生了这样一种人在门口“卡了一下”的感觉（以下称“卡门”），不够顺滑（在我们第一次使用的时候也确实产生了这样的情况）。\n今天室友对其进行了修改，将原有的 5 秒开门等待时间延长到了 15 秒，而我认为这个等待时间不应超过 8 秒，在这件事上我们的意见产生了分歧\n事件讨论 先说说我的立场：\n我从该系统制作的第一天就对该系统的安全性抱有担忧的态度。我的担心点主要在于，假设因某种原因，导致开门系统在宿舍无人的情况下将门打开，那么宿舍内的所有财物说的夸张一些，就如同是摆在车站一不起眼桌上却不知所属的蛋糕，任何过往的乘客都可在无人注视下咬上一口。\n再说说室友的立场：\n他并不认为延长开门停留时间有什么安全问题（尽管我认为只要该系统能开门就很危险，不管那是 1 秒还是 15 秒，8 秒也只是我出于同意他“卡门”这一观点的认同），反而是“卡门”严重影响了体验，以至于我多次听他提及，并终于在今日实施了修改\n争论：\n我提出观点后补充了一些我认为可能的导致开门系统在宿舍无人情况下开门的原因，例如：\n系统出现某些故障导致系统误将门打开（已知系统在重启时因自检会启动一遍，这可能发生在停电又来电后，今天才发现，不知道室友今天在修改时间的时候有没有处理这个问题） 使用者误操作，在宿舍无人情况下误将门打开（虽然你可能觉得没有谁会误操作到打开手机、点开 QQ、找到群聊、打字“开门”、点击发送这么繁琐，但我还是给机器人加了二次验证，室友对这点也觉得过于繁琐，强烈建议我改成一步） 遭到外部人员攻击（不是我高看这个系统，我们的服务器也经常遭人恶意扫描） 室友呢，觉得发生这些事情的概率太小了可以忽略，在我的争执下还给我戴了个保守主义的帽子，使得考研政治还没开始的我不得不去百度一下保守主义的详细定义。 在不同的语境下，或者不同的历史阶段，拥有不同的含义，但它们都有类似的本质：是一种强调既有价值或现状的政治哲学。保守主义一般是相对激进而言的，而不是相对进步而言的。保守主义并不反对变革，只是反对激进的变革，宁愿采取比较稳妥的方式。（来源百度百科）\n的确，我在该事的处理上并不反对变革，只是反对激进的变革，宁愿采取比较稳妥的方式（可以在原 5 秒的情况下提升到 8 秒，但不支持提升到 15 秒）。但我并不认为我在这件事上表现出的保守主义有什么问题，也对室友的贬义口气感到不快。\n话说回来，在交涉失败后，我在明知不可行的情况下放言将关闭 QQ 机器人的相关功能（他也有的是方法让他和其他室友用上开门的功能）借以恐吓他修改开门停留时间，他对我的恐吓不为所动。我又进一步放言将拆除他的硬件设备以使系统无法使用，他那这是他的财产神圣不可侵犯来压我，我表明他的系统危害了我的财产安全，他回应虽然系统能造成财产损失但还未造成，但如果我拆除那就是已经造成财产损失。那我的下一步应该是走司法程序来处理掉这个将会造成我财产损失的私有财产了。\n咳咳，当然，没有进入到最后一步，作为一起生活了三年的室友也没有必要做伤害对方的事情。\n那我咋办呢？\n至此，我发现了我在这件事情上其实没有任何的发言权，我能做的只有请求和建议，他当然可以认为我的财产安全的缺失可以同我的建议一样连屁都不是。\n思考教训 上面写了这么多其实都不是重点，虽然这样，我还是将其尽量写详细以让我看清事情的经过。\n那我从这件事情上究竟应该知道些什么呢？\n这件事情主要的矛盾点其实主要在于室友不认同我的安全性考虑，那我应该想办法让他认同吗？他和我一样不是一个会听一两句解释能改变观点的人，我有时候会觉得他很固执，我想他可能（也许是必然）也是这样看我的。那我应该去请求吗，也许给点好处？他可能并不喜欢我放屁，就算屁是香的，因为这触犯到了他崇尚的便捷（虽然我也崇尚，但或许也是保守的，但我必然不是个保守派）\n真的，我在这件事情上非常的无力，我应该做的不是去想怎么让这件事成为我所希望的样子，而是想怎么避免在将来在面对不同的人、不同情况，但却有相同或相似情况下做出的对策。\n争论的结束点在于我无法破坏他的财产来保全我的，那么或许我应该在他购买硬件时投资一笔，相当于购买保险。但这并不是个好办法，先不提对方是否同意，我认为很多时候你并不能判断一些特殊保险是否买的正确（比如买锁的时候买个锁保险，但实际效果却是在你锁坏的时候给门装一个磁铁和门框吸在一起，不让偷窃者看出锁坏了），况且这保险费可能不便宜。\n其实在事情发生前我就考虑到了一些问题，但并未立刻采取措施，而是等待事态的发展适当补救。我发现这竟然是我的一贯作风。那我或许应该想办法改变我的想法。\n该学政治了。我很讨厌被一两个别人知道个一二而我不敢确定的专业词汇压着的感觉，虽然我拿来压别人的时候很爽，但我都感觉这挺不成熟的，为什么要做一些妨碍交流的事呢？但我做的比较好的是，现在很少在和别人交流的时候卖弄我三角猫的日语。\n“抓把柄”的能力太弱了。我很难在一些事情中找到能牵制对方的事情或东西。\n不要事事都想着折中，你并不确定对方是否想跟你折中，就算他与你关系很好。利益并不总能影响关系，对方完全可以折掉你的所有利益，但你不会觉得这些利益是值得败坏你们的关系的。\n后话 其实这个系统仍然存在一个，非安全性的问题，他的存在虽然方便了开门，但如果我们都在门外，却发现停电或者断网，然而身上没带钥匙咋整。。。\n","permalink":"https://akashiya-chime.github.io/posts/%E4%BB%8E%E4%B8%80%E4%BB%B6%E6%97%A5%E5%B8%B8%E5%88%86%E6%AD%A7%E4%B8%AD%E6%80%BB%E7%BB%93%E7%9A%84%E6%95%99%E8%AE%AD/","summary":"\u003cp\u003e在最近的一件开发活动上与室友的意见发生了分歧，在分歧的处理上，我竟然发现自己完全没有话语权，我认为的个人财产安全度缺失居然连屁都不是。我认为，我必须得从这件事上总结点教训。\u003c/p\u003e\n\u003cp\u003e写作之前，先放下跑团群常驻的一个标语：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e理念冲突请保持优雅\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e另外做一些声明：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e个人并不会在此事上做更多的努力（That’s in vain）\u003c/li\u003e\n\u003cli\u003e优雅永不过时\u003c/li\u003e\n\u003c/ol\u003e","title":"从一件日常分歧中总结的教训"},{"content":"一些我常用的，或者可能用到的，或者认为比较好的一些网站汇总。\n但并不包括一些大众型的，比如百度、bilibili。\n对提到的网站进行了分类并且有简要说明。\n视频影视 樱花动漫（1）：使用量已超过 B 站的看番网站（虽然不知道哪个才是本站） 樱花动漫（2）：另一个能找到的樱花 简影：高清无广告观看各种影视，少部分番剧，网剧，但是需要每月 2￥。虽然不能极致的白嫖，但是也算是对作者的支持 AcFun：A 站，有很多你在 b 站看不到的番剧，譬如物语系列（部分）、达尔文游戏、无彩限等 Cupfox：茶杯狐，聚合网站，搜索能播放的网站 DND \u0026amp; COC 纯美苹果园：为人熟知的 TRPG 论坛 PlanarAlly：在线跑团工具，主要用于 DND 猫爷 TRPG：在线跑团工具，主要用于 COC Foundry Virtual Tabletop：著名跑团工具 FVTT，价格 50$，只需 DM 一人购买 a self-hosted, modern, and developer-friendly roleplaying platform\nFVTT 中文社区：给国内 FVTT 使用者提供便利 克苏鲁神话 中文合集：目前找到的质量最佳的克苏鲁神话翻译合集，在线观看，可下载 魔都：模组站，大量非官方模组可搜索，主要是 COC 模组 100Dice：TRPG 模组站，也包含了很多跑团工具、规则 威世智中文网：（Wizards）目前的 DND 官方，旗下还有 MTGA 等游戏 混沌元素：（Chaosium）目前的 COC 官方 跑团记录着色器：常用于对导出的 QQ 跑团记录着色 克苏鲁公社：各种克苏鲁及克苏鲁跑团 TRPG 的相关资料，大书库、图书馆 Roll20：FVTT 之前可能是最好的在线跑团工具，主要用于 DND，缺点是国内网络不友好 编程相关 JavaScript Node.js：基于 V8 的 JS 运行时（runtime）环境 npm：Node Package Manager，你的 npm install 就是从这里下载的 Vue.js：Vue3，渐进式 JS 框架（前端框架） Vite：下一代前端开发与构建工具 Element Plus：基于 Vue3 的组件库 Vant：移动端 Vue 组件库 Ant Design Vue：2.0 版本，Vue3 组件库 VuePress：Vue 驱动的静态网站生成器 React：前端框架 +1 webpack：前端项目打包工具 Electron：前端三大件构建跨平台桌面应用 ES6 入门教程：阮一峰的 ES6 教程 JavaScript 标准参考教程：阮一峰的 JS 教程 现代 JavaScript 教程：一个比较完备的 JS 教程 CSS Tailwind CSS：CSS 框架，用纯 class 写 css 学习 CSS 布局：一个简单的 CSS 布局教程 Python Python：官网 PyTorch：开源机器学习框架 TensorFlow：开源机器学习框架 +1 MXNet：深度学习框架 Go Go：官网 pkg.go.dev：用于查找 go 包 工具 CODELF：变量名查询，命名困难症福音 Neumorphism：Soft-UI 生成器，生成的是单独一个块的 AutoHotKey：AHK，Windows 下的脚本工具，强大易用 CodePen：在线前端代码编辑器 Stack Overflow：全球最大技术问答网站 峰华前端工程师：某前端大佬的网站，内含各种资源、教程 CODING：一般用来部署一些项目 Vercel：特别好用的项目托管平台 jsDelivr：免费开源 CDN，用来加速 npm、Github 文件很好用 书栈网：各种编程相关书籍、文章、文档 图灵社区：只能说，图灵的书，大部分质量很高 MiraiForum：Mirai QQ 机器人框架的论坛 Dice! 论坛：Dice! QQ 机器人，溯汇大佬的论坛 游戏相关 osu! osu!：官网 戳泡泡：在线 osu! 游玩 Sayobot osu! 镜像站：osu! 铺面的镜像站 Inso link：官方图谱快捷下载 其他 开黑啦：语音聊天软件，开黑时用，效果比 QQ 好上很多 工具类 PNG to ICO：在线将 png 文件转 ico Bigjpg：AI 图片放大 爱给网：各种 Ps、Pr 素材、游戏音效、配乐、模型等 MikuTools：各种在线小工具 钛盘：超好用的文件中转站，不限大小、上传下载均不限速 trace.moe：以图搜番 SauceNAO：以图搜图 ArchWiki：Arch Linux 的 Wiki，文档库 Notion：著名的笔记软件，Web 端 石墨文档：在线多人合作文档制作 坚果云：有时候会用到的云盘 阿里云盘：目前不限速但是单线程上传下载的网盘 鹏少资源网：鹏少的网站，内含 Windows、MacOS、Android 下各种好用方便软件的绿色纯净版，还有许多浏览器插件，另外还有很多软件正版特惠（鹏少和我一样，热衷白嫖，所以资源很不错） ACG17：一些 ACG 圈子里的东西，适合死宅的我 NGA：庞大的玩家社区，包含各种游戏，对，各种 Greasy Fork：用户脚本网站，前提是你有油猴（Tampermonkey） Overleaf：在线 LaTeX 编辑器，在我尝试多个小时本地 LaTeX 配置后回头发现，Overleaf 真香 今日热榜：各种节点的信息、热点汇总，了解国内国外大大小小的各种事情 Magi：基于机器学习的信息抽取和检索系统，简单说就是个 AI 搜索引擎 Bangumi：查看每周番剧更新 Trello：一个 TODO 看板工具，支持多人 Topbook：官网，各种效率工具、资源、技能 Hexo：快速、简洁且高效的博客框架 Windows Terminal Themes：获取 Windows Terminal 主题 失落的 galgame 资源站：搜索 galgame，包括 Windows 和 Android 端 MyGalgame：galgame 资源网 +1 TinyPNG：在线 png 图片无损压缩 LALAL AI：AI 人声伴奏分离工具 FreeAPI：一些 API 接口，虽然有很多亲测不能用。。。 全历史：挺出名的历史爱好者会为之疯狂的网站 Photopea：在线 Photoshop 文档相关 PyQt5：Python 的一个基于 Qt 的 UI 库 Gin：一个 Go 语言 Web 框架 Gin（2）：鉴于官方文档看着难受，简书上找了一篇 Mirai-js：简单的开源 Mirai QQ 机器人框架 Mirai：Mirai 机器人框架的开发文档 Fluid：目前在用的 Hexo 主题 相关阅读 24 Best FREE Photoshop Plugins \u0026amp; Filters: Still Good in 2022\n","permalink":"https://akashiya-chime.github.io/posts/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/","summary":"\u003cp\u003e一些我常用的，或者可能用到的，或者认为比较好的一些网站汇总。\u003c/p\u003e\n\u003cp\u003e但并不包括一些大众型的，比如百度、bilibili。\u003c/p\u003e\n\u003cp\u003e对提到的网站进行了分类并且有简要说明。\u003c/p\u003e","title":"常用网站汇总"},{"content":"2021年8月最后一天结束了，这里象征性地做一个总结，想想自己这个假期干了些啥\n就没什么实质性的东西了，水一水，准备写 ArchLinux 美化\n番剧 这个假期干的最多的一件事就是看番，新番老番都在看\n看番的地点更多的是在樱花了，b 站是越来越不行了，b 站剪辑技术倒是好了不少\n稍微清点一下看的番：（由于不在 b 站看，所以并不能写全）\n已完结：\n齐木楠雄的灾难 寄生兽 影宅 Re0 第二季 咒术回战 东京喰种 物语系列（二周目） 伤物语 化物语 伪物语 （还在看，可能会把 A 站有的和 b 站有的刷一遍） 在更：\n龙女仆第二季 迦希女王不会放弃 魔法少女小圆外传第二季 关于我转生变成史莱姆这档事第二季 女友成双 死神少爷与黑女仆 Arch Linux 干的更多的另一件事就是搞 Linux 系统了，现在也还在完善，还有几篇文章要写，总体体验上还是蛮不错的，之前顾虑的软件少什么的并不存在，之前在 Windows 下的工作栈也基本补全了\nQQBot 结合着 Mirai 做了点东西，满足了些日常的需要，有空还会在写点东西，看群友有没有需求\nBlog 今天也是加把劲战士呢，还是在努力写 Blog 呢（虽然没人看（但是可以自己看啊））\n然后就是这两天给 Blog 换了个主题，然后挂 vercel 上了，国内速度应该会快一点，图床可能得解决一下，jsdelivr 得用上\n后话 接下来应该要写一篇 Arch Linux KDE 美化，然后写一篇我在用的一些软件的汇总（顺便期待一波室友的油猴教学）\n在这之前，因为多次经历浏览器同步之苦，决定先写一篇自己的浏览器扩展以及常用网站汇总，拿来当备份吧\n9月了，也得加油了呢\n","permalink":"https://akashiya-chime.github.io/posts/%E5%81%87%E6%9C%9F%E6%80%BB%E7%BB%932/","summary":"\u003cp\u003e2021年8月最后一天结束了，这里象征性地做一个总结，想想自己这个假期干了些啥\u003c/p\u003e\n\u003cp\u003e就没什么实质性的东西了，水一水，准备写 ArchLinux 美化\u003c/p\u003e","title":"假期总结（2）"},{"content":"本人安装 Arch Linux 时的参考及步骤\n主要包含：启动盘制作到磁盘分区到最后驱动安装和最后图形界面安装（针对 Windows 转 Linux，UEFI 方式）\n参考 因为是按着步骤装的，所以先把参考搬出来\n【超详细教程】Arch Linux真机安装教程 - 从命令行到图形界面 | 2021年3月\n装前须知 这个可能会成为一个坑，特别是不太了解操作系统或者相关东西的人（比如我），容易完了留麻烦，所以先说\n怎么回事呢，是这样的，我电脑的储存空间一直是我的心头病，我只有一个 256G 的 SSD，在 Windows 下划分成了 C 盘和 D 盘俩分区，然后一直把 100G 的 C 盘作为系统盘，每次重装系统都只会影响到这个盘的文件，而我的 D 盘得以保全。所以我准备这次也对我的 C 盘动手，想着这样能保全我 D 盘的重要文件。\n但是装系统的时候出现了两个问题：\n一是原 Windows 的磁盘分区比较神奇，除了 C D 两盘的区域外还有几个分区，具体用处我不是很清楚，正好呢，我格式化除 D 盘的分区时发现，其他分区居然不是连续的，在物理上，D 盘扇叶后，还有 901.3MB 的空间，这可能会影响到你的磁盘分区和挂载\n二是，Windows 支持的磁盘格式一般是 FAT32 或者 NTFS，然而 Linux 不支持 NTFS，这会导致什么呢：\n那有没有解决办法呢？目前我能找到的都需要格式化x，以宿舍不到 5MB 的网速把我这 100 来 G 的文件上传格式化后又下载下来可能不是一两天能解决的。\n所以装 Linux 前请一定注意以上问题。\n我的硬件 常用操作：Ctrl + L 清屏，很好用\n下镜像 https://archlinux.org/download/\n推荐 也可前往其他中国镜像地址下载 制作启动盘 有推荐使用 Rufus 我用了下，发现做出来的启动盘有点问题，我的电脑找不着，所以用的视频里提到的工具：Etcher\n工具使用比较简单，只需要注意推荐 8G 以上的 U 盘\n找到对应 U 盘（一定看清别搞错了）和镜像文件（.iso）然后一键完成\n进入镜像 打开百度，搜索自己机型对应进入 BIOS 的键（我的是 F2），关机，进入 BIOS\nBoot -\u0026gt; Security Boot 更改为 Disabled\n打开百度，搜索自己机型对应进入启动项的键（我的是 F10），关机，进入启动项，找到 U 盘，进入镜像\n连网 1 $ iwctl 进入 iwd\n1 $ device list 查看无线网卡，比如 wlan0\n1 $ station wlan0 scan 进行扫描\n1 $ station wlan0 get-networks 查看扫描到的网络\n1 $ station wlan0 connect [Network name] 连接网络，根据提示输入密码（如果需要）\nCtl+C 或者输入 exit 退出 iwd\n退出 iwd 后可使用 ping 来检查有无网络\n验证启动模式 1 $ ls /sys/firmware/efi/efivars/ 视频里讲说有很多如果里面有很多东西，那么说明有 UEFI，未考证准确性\n同步时间 1 $ timedatectl set-ntp true 可以通过以下方式查看\n1 $ timedatectl status 磁盘分区 1 $ lsblk 列出块设备信息\n我就一个 256G 的 SSD，lsblk下显示的 nvme0n1（nvme应该是某接口规范的缩写）\n印象里 Windows 给分了 6 个区，我的 nvme0n1p2 是 C 盘，nvme0n1p3 是 D 盘\n所以要将除了 nvme0n1p3 外的都给清了，连续的分区会自动合并\n我们使用 gdisk 命令，比如：\n1 2 3 4 5 $ gdisk /dev/nvme0n1p1 Command(? for help): x Expert command(? for help): z (Y/N): y (Y/N): y 当然，如果你不像我只有一个固态，而是有很多，而且你拿来做系统盘的这个盘又没有存重要文件或者已经备份，那么你完全可以直接清顶层（比如 nvme0n1）\n为了方便，以下以完全清除 nvme0n1 来进行\n1 $ cgdisk /dev/nvme0n1 进入这个 cgdisk 分区工具（当然也有别的，只是觉得这个好理解）\n[ New ] 具体操作可参考推荐视频，下表列出主要配置\nFirst sector Size Hex code name default 一般300MiB(1024MiB) ef00 boot default (4GiB) 8200 swap default (30GiB) default root default default default home 有几点说明：\n括号内为我的配置\nboot（启动分区） 和 swap（交换分区）的 Hex code 一般来说应该是一样的，如果你不清楚，可以在填写时输入 L 回车查询\nefi：查询 boot 的 Hex code swap：查询 swap 的 Hex code swap 的 Size 参考下表（我是 8G 内存，可以设 3 GiB，我凑个偶数）\n至于 swap 是干嘛的，其实就是拿来补你内存的，内存使用满了，可以拿一部分 swap 分区的内存来补\nswap分区，即交换区，swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用\n理论上 root 和 home 分区可以合为一个分区，这里为了方便管理，所以分成两个\n如果你装软件装的多，请一定给 root 分区多一点空间，这是血的教训，我这给的 30GiB 对我来说根本不够（推荐你翻个倍，或者你盘够大，给的更多也没关系，你可以把 root 看成 Windows 下的 C 盘，而且所有应用都装 C 盘下，home 就是 D 盘，放你个人文件的地方）\n再说一遍，如果你装软件多，请一定给 root 多一点空间\n{% note primary %} 2022年12月30日注：一定一定多给点，我本以为之前给得够多了，但是发现其实并不够。其实在Linux下可能就自己下的什么视频啥的占了点home的空间，各种奇奇怪怪的软件下下来是放root里的，所以还是给多点吧。 {% endnote %}\n[ Write ] yes\n[ Quit ] 磁盘挂载 挂载前要先对分好的分区格式化\n假设 n1p1 是你的 boot，n1p2 是 swap，n1p3 是 root，n1p4 是 home\n1 2 3 4 5 $ mkfs.fat -F32 /dev/nvme0n1p1 $ mkswap /dev/nvme0n1p2 $ swapon /dev/nvme0n1p2 $ mkfs.ext4 /dev/nvme0n1p3 $ mkfs.ext4 /dev/nvme0n1p4 挂载\n1 2 3 4 5 $ mount /dev/nvme0n1p3 /mnt $ mkdir /mnt/boot $ mount /dev/nvme0n1p1 /mnt/boot $ mkdir /mnt/home $ mount /dev/nvme0n1p4 /mnt/home 如果你不准备将 root 和 home 分开，那么就没有最后两步\n修改 pacman 镜像 文件编辑器可以选择 nano 或者 vim，看个人喜好，这里使用 vim\n1 $ vim /etc/pacman.d/mirrorlist 该文件存放了 pacman 的镜像地址，pacman 使用镜像的方式是从上到下，所以有的教程会让你把中国镜剪切到最前，这里不这样做，用一个更好的方法\n1 2 $ pacman -Sy $ reflector --verbose --latest 15 --sort rate --save /etc/pacman.d/mirrorlist pacman -Sy 先同步一下\nreflector 是个同步脚本\nReflector 是一个 Python 脚本；它可以从 Arch Linux Mirror Status 页面获取最新的镜像列表，然后筛选出最新的镜像并按速度排序，最后将结果写入到 /etc/pacman.d/mirrorlist 文件。\n这里稍微解释一下各个参数的含义：\n--verbose：log 到终端 --latest 15：最近 15 个 --sort rate：按速率排序 --save /etc/pacman.d/mirrorlist：保存到该文件 其实这里可以再加一个 country China 来选择中国源 安装系统及固件 1 $ pacstrap -i /mnt linux linux-headers linux-firmware base base-devel vim intel-ucode 说明：\nvim 也可换成 nano 或者一起装上 intel-ucode 取决于你的处理器类型，如果你是 AMD，那么 amd-ucode 进入系统 1 2 $ genfstab -U -p /mnt \u0026gt;\u0026gt; /mnt/etc/fstab $ arch-chroot /mnt 如果你发现终端行头变成了比如：[root@archiso /]#，那么说明你已经进入了系统\n进入系统第一件事，同步一下\n1 $ pacman -Syy 然后配置系统时区 1 2 $ ln -s /usr/share/zoneinfo/Asia/Shanghai \u0026gt; /etc/localtime $ hwclock --systohc 然后语言配置 1 $ vim /etc/locale.gen 进入该文件后，将 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 前面的 # 删掉（取消注释）\n:wq退出\n1 2 3 $ locale-gen $ echo LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf $ export LANG=en_US.UTF-8 网络配置\n1 $ vim /etc/hostname 这里输入一个名字，按个人喜好，这里以 arch-name 为例\n:wq 退出\n1 $ vim /etc/hosts 写入以下内容：\n1 2 3 127.0.0.1 localhost ::1 localhost 127.0.1.1 arch-name.localdomain arch-name :wq 退出\n然后添加用户 1 2 3 4 5 $ passwd # 两次输入密码 $ useradd -m -g users -G wheel,storage,power -s /bin/bash archuser $ passwd archuser # 两次输入密码 这里的 archuser 是你的用户名，可以自行填写\n修改 sudo 文件 1 $ EDITOR=vim visudo 去掉 Uncomment to allow members of group wheel to execute any command 下一行 %wheel ALL=(ALL) ALL 前面的 #\n再在文件最后添加 Defaults rootpw\n:wq 退出\n安装启动器 1 2 $ bootctl install $ vim /boot/loader/entries/arch.conf 写入以下内容\n1 2 3 4 title My Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img 第二行如果使用长期支持内核则写 linux /vmlinuz-linux-lts\n:wq 退出\n1 $ echo \u0026#34;options root=PARTUUID=$(blkid -s PARTUUID -o value /dev/nvme0n1p3) rw\u0026#34; \u0026gt;\u0026gt; /boot/loader/entries/arch.conf 上面这个语句会帮你补充 arch.conf 内的最后一行\n开启 32 位支持（可选） 如果你没有 32 位应用支持需求，则直接下一步（我没有）\n{% note primary %} 2022年12月30日注：现在看来，还是有一些需求的，但是到时候开也没问题 {% endnote %}\n1 2 $ systemctl enable fstrim.timer $ vim /etc/pacman.conf 去掉 [multilib] 和 Include = /etc/pacman.d/mirrorlist 前的 #\n:wq 退出\n然后同步一下\n1 $ pacman -Syy 安装各种工具、驱动 网络、声音、蓝牙、文件后台 1 $ pacman -S networkmanager network-manager-applet dialog wpa_supplicant dhcpcd 启用\n1 $ systemctl enable NetworkManager 继续\n1 $ pacman -S mtools dosfstools bluez bluez-utils cups xdg-utils xdg-user-dirs alsa-utils pulseaudio pulseaudio-bluetooth reflector openssh 显卡 这里以我的配置来（不开启 32 位支持，intel，NVIDIA），32 位及 AMD 相关请参考推荐视频\n1 $ pacman -S xf86-video-intel mesa libva-mesa-driver mesa-vdpau nvidia dkms libglvnd nvidia-utils opencl-nvidia nvidia-settings 显卡驱动配置 1 $ vim /etc/mkinitcpio.conf 将 MODULES=() 修改为 MODULES=(nvidia nvidia_modeset nvidia_uvm nvidia_drm)，顺序不能错\n:wq 退出\n1 2 $ mkdir /etc/pacman.d/hooks $ vim /etc/pacman.d/hooks/nvidia.hook 输入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 [Trigger] Operation=Install Operation=Upgrade Operation=Remove Type=Package Target=nvidia Target=linux [Action] Depends=mkinitcpio When=PostTransaction Exec=/usr/bin/mkinitcpio -P :wq 退出\n1 $ vim /boot/loader/entries/arch.conf 在 options 这一行的后面添加：nvidia-drm.modeset=1\n如果你是 AMD，那么添加 amdgpu.dmp=0 amdgpu.noretry=0\n:wq 退出\n安装图形界面（以 KDE 为例） 装 xorg 窗口系统 1 $ pacman -S xorg konsole 视频里推荐装个 xterm 然后进了图形界面后又用 xterm 装了 konsole，那为什么不直接在这装 konsole 呢\n（一定要装一个终端，不论你是装 xterm 还是 konsole，不然进去发现没有，又得插 U 盘挂载进系统然后装，很麻烦）\n装 KDE 1 $ pacman -S sddm plasma 重启 1 $ exit 退出系统\n1 $ umount -R /mnt 取消挂载\n1 $ reboot 重启\n输入密码，你就进入图形界面的桌面了\n至此，装系统到图形界面应该就算结束了，但为了接下来的使用，装一些基本的软件\n装基本软件 打开 konsole\n1 $ sudo pacman -S neofetch dolphin firefox ark p7zip git wget kate bashtop neofetch 就是最开始我看系统和硬件信息的工具\ndolphin 是文件管理器\nfirefox 在 Linux 下支持的比较好\nark 和 p7zip 是压缩管理器\ngit 和 wget 广为流传\nkate 是文件编辑器\nbashtop 是终端进程管理器\n后话 接下来规划出一期 Linux 美化，一期 Linux 常用软件推荐。\n","permalink":"https://akashiya-chime.github.io/posts/arch-linux-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","summary":"\u003cp\u003e本人安装 Arch Linux 时的参考及步骤\u003c/p\u003e\n\u003cp\u003e主要包含：启动盘制作到磁盘分区到最后驱动安装和最后图形界面安装（针对 Windows 转 Linux，UEFI 方式）\u003c/p\u003e","title":"Arch Linux 安装记录"},{"content":"有关 QQ 机器人框架 Mirai 下的基于 Node.js 的框架 Mirai-js\nMirai是一个免费开源的QQ机器人框架，由于其开源和易拓展的优势，现在已经有很多基于Mirai的官方和非官方衍生框架和应用，其关系错综复杂。\nMirai-js，一个运行在 Node.js、浏览器下的，简单的 QQ 机器人开发框架。\n前言 自从之前为人们广为熟知的 QQ 机器人框架「酷Q」停止运营，晨风机器人的作者被请喝茶后，一时间很多 QQ 机器人开发者开始陷入彷徨，不知何去何从。但总归 QQ 机器人的需求不会停止，新的框架会应运而生。\n我在酷Q时代一直使用的插件「Dice!」的作者溯洄很快将框架转移到 Mirai 上，我也就了解到了这个框架。\n溯洄大佬的 Dice! 论坛：Dice! 论坛 (kokona.tech)\n虽然开始用的时间比较早，但是实际上也只是前不久才开始着手开发自己的部分。\n因为之前一直只拿 Dice! 当跑团骰子用，并没有想过开发点别的东西\n另外就是因为酷Q时代开发使用易语言给我带来的阴影\n不过等一段时间还是好的，毕竟需要框架本身进行一段时间自我完善，能够稳定或发展生态为开发者提供良好平台（别骂了别骂了，是我懒:cry:）\n先从 Mirai 说起 Mirai 是使用 Kotlin 开发的，支持插件，一般用户可直接上论坛找大佬发布的插件装上就用\nMirai Github repository\nMiraiForum\n如果要参与开发，原生的当然是使用 kotlin，但是呢，也有一些原生的，如下：\n技术 维护者及项目地址 Kotlin Scripting iTXTech/mirai-kts C++ Nambers/MiraiCP JavaScript iTXTech/mirai-js 酷 Q DLL 插件 iTXTech/mirai-native 但是呢，这些原生的可能用着很难受\n也许你注意到了 mirai-js，但和本文将要介绍和使用的 Mirai-js 并不是同一个东西，虽然我有尝试过使用 mirai-js 但是操作繁琐且 API 不全，就没有深入了解了\n除此之外呢，还有基于 Mirai HTTP 生态下的第三方项目，如下\n语言和技术\t维护者及项目地址\n语言和技术维护者及项目地址C#Executor-Cheng/mirai-CSharpC#HyperaiC#Coloryr/ColorMiraiC#AhpxChina/Mirai.NetC#Cyl18/ChaldeneC#Miyakowww/CocoaFramework2C++cyanray/mirai-cppC++Chlorie/miraippGDScriptXwdit/RainyBot-CoreGoLogiase/gomiraiJavaScript / Node.jsRedBeanN/node-miraiJavaScript / Node.jsdrinkal/Mirai-jsJavaScript / TypeScriptYunYouJun/mirai-tsJavaScript / TypeScriptnepsyn/miraipieJuliaMiraiBots.jlPHPnkxingxh/miraiezPythonAliceBotPythonAriadnePythonAvillaPythoneasyMiraiPythonEdovesPythonElainaPythonNoneBotPythonjerrita/saayaPythonYiriMiraiPythonExcaive/miraicleRubyShimogawa/rubiraiRustHoshinoTented/mirai-rs易语言only52607/e-mirai易语言Novices666/mirai-epl Mirai 生态 Mirai 的生态发展的有点复杂了，就如同官方文档所说的「错综复杂」，这花了我很多时间去理清他们之间的关系，一下提两句，有助于之后的开发\nmirai-core 是 Mirai 对 QQ 的具体协议实现，它承担具体且核心的工作。\n这里放一张官方文档的图：\n核心与底层的东西，前期了解太多不利于快速上手应用，所以了解个大概，知道底层是这个 core 在跑。\nmirai-console mirai-console 就是 Mirai 官方开发组编写的 QQ 机器人程序，它在 Mirai 框架提供的基础功能的基础上进行了封装并进一步提供了更方便的开放接口。\n就是一个终端，官方提供了命令行界面，你拿它来登陆你的 QQ 机器人，并对其进行部分操作。\n官方还讲其分了前端后端的概念，感觉有些不便于理解，暂且不提。\nmirai-api-http mirai-api-http 插件就是一个将 mirai-core-api 的所有功能封装为 http 服务的插件，同时也提供了 WebSocket 服务。\n比较核心的一个组件了，基本上所有第三方基于 Mirai 的框架都需要这个组件。http 和 websocket 为你提供类似服务器一样的地址和端口，你使用第三方框架的时候只需要监听这个端口即可与 Mirai 进行交互。\nmirai-native 如果你是 酷Q 用户，想在 Mirai 中使用 酷Q 插件，你可以使用 mirai-native 插件，它可以加载 CQP.dll 并兼容大部分酷Q 插件，但不支持 CPK 和解包的 DLL。\n给原酷Q用户的一个迁移端口（蛮良心的），实际上溯洄大佬的 Dice! 应该也是从这个为起点的。\n但是官方文档也指出，酷Q既然也停止服务，那么就不推荐使用\nmirai-console-loader mirai-console-loader 应运而生，它的工作就是简化 console 启动流程，一键帮你下载 jar 文件，自动更新，文件损坏检查…… 你能在手动启动时担心的问题 mirai-console-loader 都帮你想到了！\n官方缩写 MCL，mirai-console 的一键启动器，类似对 mirai-console 的封装，简化操作的，当然，坑也不少。\n虽说他是怕你不懂 JVM，怕你被劝退，但是这个 MCL 的有些操作同样有点劝退人的味道。\n关于 Mirai 生态的后话 发展生态有好处也有弊端，好处是使其多元化，体现开源的特色，坏处是，花样一多，你不得不考虑他们之间的同步问题，他们之间版本跟新是否跟得上会很大程度影响开发体验，或者说给新手埋下多少坑（没错我就是受害者）。然后就是，不太好做文档，这牵一发而动全身的感觉着实不太好。\n关于 Mirai 社区和插件 论坛活跃度还是蛮高的，一些常见的问题可以通过论坛的搜索功能查找。\n你可以在论坛中看到官方发的公告（目前，最近一次在 2021 年 5 月 19 日），参与讨论，提交 Bug 反馈，分享插件。\n对于插件，论坛上给的插件基本都是编译成 jar 文件的，只需要放入 MCL 的 plugins 文件夹下，然后重新启动就能使用，比较类似酷Q，还是蛮方便的。\n大佬们给了很多有趣的插件，详询论坛插件板块。\n然后说 Mirai-js 运行在 Node.js、浏览器下，基于 mirai-api-http 的 QQ 机器人开发框架。\n特点就是基于 node，快速上手，全文异步，涵盖基本一个 QQ 账号能做的所有基本操作，包括但不限于：\n发送消息 戳一戳 发送图片 @ 发送语音消息 发送 XML 和 JSON 在群组中也具有一定的功能，包括但不限于：\n禁言 踢人 退群 设置群配置： 群名称 群公告 是否开启坦白说 是否允许群员邀请 是否开启自动审批入群 是否允许匿名聊天 设置群精华消息 项目地址：Drincann/Mirai-js\n文档，API\n正片：开发一个基于 Mirai-js 的 QQ 机器人 创建一个 QQ 小号 一般来说都不会让你用大号来做机器人，到时候要是有什么闪失号玩没了就哦豁了。\n另外就是 tx 神奇的检测机制，你的 Bot 有时会发不出消息（实际上已经发了，但是被 tx 给屏蔽了），这时往往需要自己手动挂一段时间的小号，并且不知道要挂多久。\n如果你喜欢，请美化你的小号，然他/她成为大家的吉祥物:joy:\n安装 MCL 官方提供了一键安装工具 MCL-Instller，找到最新版本，下载对应系统的版本到一个本地空文件夹，这个文件夹就是你的项目文件夹。\n运行后，根据官网，如果你是新手，那么一路回车。\n注：\n可能会有不一步到位的情况，可能装完 java 他就停了，那么再运行一遍 有可能会有网络不佳的情况，视情况上tizi 当文件夹中出现 mcl.cmd 文件时即安装完成，双击或 cmd 运行 mcl.cmd，第一次执行会自动安装依赖，最后出现 successfully 即完成。\n这个时候就可以试试登陆你的小号了\n1 $ login [qq号] [密码] OK，登上了的话，那么应该没啥问题\n安装 mirai-api-http 官网推荐你使用 MCL 自动更细插件的安装方式：\n$ ./mcl \u0026ndash;update-package net.mamoe:mirai-api-http \u0026ndash;channel stable \u0026ndash;type plugin 但是呢，我不推荐，这里不得不说 Mirai 生态下的坑。\n执行以上命令后，他会讲 mirai-api-http 的依赖给 MCL，在你下次执行 mcl.cmd 的时候会检测出来并安装，但是呢，就我目前的时间点，自动安装的 mirai-api-http 版本过低，然后直接报错：\n我看不懂，但是我大受震撼。百度甚至告诉我是 kotlin 版本问题，论坛上给出修改 config.json 文件，关闭自动更新等等方法，我只能说我不中嘞。不知道你在操作的时候，他修补这个 bug 没有。\n所以，我推荐的方法：手动安装：\n前往项目仓库：mirai-pai-htttp，找到最新的 release，下载那个 jar 文件，把它放到你的项目文件夹下的 plugins 目录下，然后运行 mcl.cmd，搞定。 修改 mirai-api-http 配置 来到 Mirai-js 文档，打开准备工作，他会让你线修改 mirai-api-http 的配置，打开 config\\net.mamoe.mirai-api-http\\setting.yml，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ## 配置文件中的值，全为默认值 ## 启用的 adapter, 内置有 http, ws, reverse-ws, webhook adapters: - http - ws ## 是否开启认证流程, 若为 true 则建立连接时需要验证 verifyKey ## 建议公网连接时开启 enableVerify: true verifyKey: yourVerifyKey ## 开启一些调式信息 debug: false ## 是否开启单 session 模式, 若为 true，则自动创建 session 绑定 console 中登录的 bot ## 开启后，接口中任何 sessionKey 不需要传递参数 ## 若 console 中有多个 bot 登录，则行为未定义 ## 确保 console 中只有一个 bot 登陆时启用 singleMode: false ## 历史消息的缓存大小 ## 同时，也是 http adapter 的消息队列容量 cacheSize: 4096 ## adapter 的单独配置，键名与 adapters 项配置相同 adapterSettings: ## 详情看 http adapter 使用说明 配置 http: host: localhost port: 8080 cors: [*] ## 详情看 websocket adapter 使用说明 配置 ws: host: localhost port: 8080 reservedSyncId: -1 这与 Mirai-js 文档给出的稍有不同，以下是文档中的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 adapters: - http - ws debug: false enableVerify: true verifyKey: INITKEYpff86IGV singleMode: false cacheSize: 4096 adapterSettings: http: ## http server 监听的本地地址 ## 一般为 localhost 即可, 如果多网卡等情况，自定设置 host: localhost ## http server 监听的端口 ## 与 websocket server 可以重复, 由于协议与路径不同, 不会产生冲突 port: 8080 ## 配置跨域, 默认允许来自所有域名 cors: [*] ws: ## websocket server 监听的本地地址 ## 一般为 localhost 即可, 如果多网卡等情况，自定设置 host: localhost ## websocket server 监听的端口 ## 与 http server 可以重复, 由于协议与路径不同, 不会产生冲突 port: 8080 ## websocket 用于消息同步的字段为 syncId, 一般值为请求时的原值，用于同步一次请求与响应 ## 对于由 websocket server 主动发出的通知, 固定使用一个 syncId, 默认为 ”-1“ reservedSyncId: -1 这里你需要自己定义并记住 verifykey，然后记住 port，下面要用\n开始使用 Mirai-js 以上的准备工作都做完了，现在正式开始。\n先把小号在 MCL 里登上。\n然后随便找个文件夹，推荐是空的，取个好听的名字，打开 cmd，cd 到这个文件夹然后：\n该项目上架了 npm，所以可以直接 install\n1 $ npm install mirai-js 或者使用 yarn\n1 $ yarn add mirai-js 以下是官网的一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 const { Bot, Message, Middleware } = require(\u0026#39;mirai-js\u0026#39;); (async () =\u0026gt; { try { const baseUrl = \u0026#39;http://example.com:8080\u0026#39;; const verifyKey = \u0026#39;verifyKey\u0026#39;; const qq = 1234567890; const password = \u0026#39;password\u0026#39;; const bot = new Bot(); // 在 mirai - console 登录一个账号 await Bot.sendCommand({ baseUrl, verifyKey, // 指令名 command: \u0026#39;/login\u0026#39;, // 指令参数列表，这条指令等价于 /login 1019933576 password args: [qq, password], }); // 创建一个会话 await bot.open({ // mirai-api-http 的服务端地址， baseUrl, // 要绑定的 qq，须确保该用户已在 mirai-console 登录 qq, // verifyKey 用于验证连接者的身份，在插件配置文件中设置 verifyKey, }); // 监听好友消息事件 bot.on(\u0026#39;FriendMessage\u0026#39;, async ({ messageChain, sender: { id: fromQQ, nickname: fromQQNickName, remark } }) =\u0026gt; { console.log({ fromQQ, fromQQNickName, remark }); const { id: messageId } = messageChain[0]; bot.sendMessage({ friend: fromQQ, quote: messageId, message: new Message().addText(\u0026#39;hello world!\u0026#39;), }); }); // 监听群消息事件 bot.on(\u0026#39;GroupMessage\u0026#39;, async ({ messageChain, sender: { id: fromQQ, memberName: fromNickname, permission: fromQQPermission, group: { id: fromGroup, name: groupName, permission: botPermission } } }) =\u0026gt; { console.log({ fromQQ, fromNickname, fromQQPermission }); console.log({ fromGroup, groupName, botPermission }); // 复读机 ;) const { id: messageId } = messageChain[0]; bot.sendMessage({ group: fromGroup, quote: messageId, messageChain }); // 你可以像这样来判断群成员的权限 switch (fromQQPermission) { case Bot.groupPermission.OWNER: // 群主 break; case Bot.groupPermission.ADMINISTRATOR: // 管理员 break; case Bot.groupPermission.MEMBER: // 普通群成员 break; } }); // 使用中间件 // 过滤分类 message bot.on(\u0026#39;FriendMessage\u0026#39;, new Middleware() .messageProcessor([\u0026#39;Plain\u0026#39;, \u0026#39;Image\u0026#39;]) .textProcessor().done(({ // 第一个中间件，分类过的 messageChain classified, // 第二个中间件，文本部分 text, messageChain, sender: { id: fromQQ, nickname: fromQQNickName, remark } }) =\u0026gt; { console.log({ fromQQ, fromQQNickName, remark, messageChain, classified, text }); bot.sendMessage({ friend: fromQQ, message: new Message().addText(text), }); })); // 自动重新登陆 bot.on(\u0026#39;BotOfflineEventForce\u0026#39;, new Middleware() .autoReLogin({ bot, baseUrl, verifyKey, password }) .done() ); } catch (err) { console.log(err); } })(); 然后保存运行（例如以上例子文件名为 test.js）\n1 $ node test.js 这样一个复读姬就产生了，你可以与你的小号对话，他会返回你的话。或者你可以把他拉进群聊，让群复读机+1。\n后话 最后的开发工作就是查 API 了，也没啥好说的，就是一点 js async/await 的知识，开发还是蛮快的，如果你有服务器的话，把 MCL 和你的文件一起丢服务器上跑起来就可以24小时了。\n参考： Drincann/Mirai-js: 运行在 Node.js、浏览器下，基于 mirai-api-http 的 QQ 机器人开发框架。 (github.com)\nDice! 论坛 (kokona.tech)\n主页 | MiraiForum (mamoe.net)\nMirai | mirai (mamoe.net)\nMirai-js 简单的开源 Mirai QQ 机器人框架\n","permalink":"https://akashiya-chime.github.io/posts/mirai-js%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003e有关 QQ 机器人框架 Mirai 下的基于 Node.js 的框架 Mirai-js\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMirai是一个免费开源的QQ机器人框架，由于其开源和易拓展的优势，现在已经有很多基于Mirai的官方和非官方衍生框架和应用，其关系错综复杂。\u003c/p\u003e\n\u003cp\u003eMirai-js，一个运行在 Node.js、浏览器下的，简单的 QQ 机器人开发框架。\u003c/p\u003e\u003c/blockquote\u003e","title":"Mirai-js使用"},{"content":"本文包含并不限于以下内容：\n拿到 ECS 搞到域名后进行域名备案\nVite2 + Vue3 + TypeScript + Element-Plus 搭建前端项目\nnodejs + express 搭建后端后使用 Go 重构后端\n前言 之前本来想写个4月总结的，但4月确实没啥写的，加上4月还算在认真学习，就咕了，4月底决定和室友合租一服务器，之后花了大半个月的时间搞域名备案，期间呢，兴趣上来了，开始尝试用新生态借着服务器好好做一个前端项目，又拿 node 做了后端，5月过半，高数的复习陷入了一种莫名的疲软，感觉一直找不到做题的感觉，学到重积分，但题一直没法向前做着走，就准备搞点别的东西让自己缓缓（然而要准备开始复习专业课了，难受）。Golang，或者叫 Go 吧，Google 里的人开发的，静态强类型，编译型，很像 C，但比 C 安全、好用，天生支持高并发，用过的都说香（所以为什么函数不支持可选参数和默认参数）。所以拿来做后端 Web 服务针不戳，试试。\n域名备案 这可真是个辛苦的差事，辛苦我室友了。\n我们在去听某人工智能讲座的时候就开始讨论取域名的事，这也不是件容易的事 :joy:，换来换去才把价格高、被占用、不「好看」的域名给避开。然后就是让人头大的域名备案了，不是亲身经历还真不敢信这东西这么复杂。因为是从阿里买的域名，通过阿里备案，先在阿里过个审，填各种表，把各种各样的个人信息填了个全，就生怕网警找不到你。他们处理了好几天（还算快吧），然后有专人给我们打电话，说他们那边完事了，已经把信息给管局（通信管理局）了，还得去管局短信验证，然后，好家伙，「12天左右回复」，正好又赶上五一假，拖了有半个月管局才给回复说过了，叫把备案号挂网站上，又说可能按地方网警要求还得去搞个公安备案，又是「把身上有几颗痔数清楚了填上去」（你别说，就我写此文的时候，还没拿到公安备案号）。总结来说，要想备案，做好被「扒光」的准备以及十足的耐心。\n搭建前端项目 Vue3 发布有一段时间了（春节左右发布），开始想接触接触了，加上 Vite2 发布了，看了一眼发现好像挺香的，这不又有服务器了嘛，怎么能没有想在浏览器地址栏敲上个 IP 就能看到点东西的冲动呢，所以就开始执行了。\n虽然不知道要想做成个啥样子，但出于学习的目的就都试试（淦，我软件工程学了个啥？），第一步，新建 .psd，还是线在 notion 上开了个页面放自己的 Todo List，自己觉得这个还是很有必要的，知道自己一向做这些东西的时间跨度比较大，怕忘了自己做过什么骚操作结果忘了出大事。\n然后就是喜闻乐见的新建文件夹开始疯狂 npm init @vitejs/app 选择 vue，选择 ts，写不来样式得找个组件库，嗯 npm install element -S ，哦淦，得是支持 Vue3 的版本，uninstall 了重新 npm install element-plus -S，那肯定得整个 Router，npm install vue-router@4，嗯，然后呢。。。\n玩过一阵子的 Vue2，就照着之前的记忆开始建 components，开始建 router，虽然是 TypeScript，但好歹学过一点，做的时候还专门借了基本 ts 的教材，所以基础的写写没有太大问题，然后就是疯狂查 Element-Plus 的文档和 API 了，虽然方便，但用着难受，有着各种各样的 bug，就用了几个组件就修了几天 bug，这些 bug 来自 ts、来自组件本身、最多应该还是来自 Vue3。\nVue3 相较 Vue2 还是改了很多东西的（至少我用着把自己用自闭了），一个生命周期上的 setup() （也就是所谓的 Composition API ？），我找了各种视频讲解，对着文档仔仔细细看了好几遍才懂了个大概（视频都讲的比较底层，然而我现在是想知道怎么用，看得有点晕）。\n这里列出一个绕了几天的问题做个例子。我准备在 HomePage 上放一个走马灯轮播室友给的猫猫图，所以找到 Element-Plus 的走马灯组件，最终选取了卡片式的这种类型\n走马灯上的图片是通过 v-for 遍历上去的，我把 item 做成 img 标签，通过 :src=\u0026ldquo;item\u0026rdquo; 属性来填充图片地址，然后被遍历的对象应该是一个数组，里面放图片的静态位置或者通过图床后的 url，和室友讨论后决定使用图床。然后我想了想，准备把 url 保存在服务器，然后通过 GET 把它发回到前端来（虽然现在想想自己的操作挺迷幻了，不知道自己绕来绕去是追求个啥）。\n后端接口很快写好，前段这边 Ajax 一下。然后呢，第一个问题来了，以前 Vue2 时的数据是放在 data() 里面的，Vite 给我的模版里面也确实有，那么我要做的就是在 Vue 组件挂载之前把 url 从后端那里拿到然后放到 data() 里就好了。\n为了满足这个时机要求应该使用生命周期，放在 Vue2 我一般会放在 mounted 或者之前，但在这里使用的时候我去查了 Vue3 的 API，发现这里发生了改变\n而且这些函数还得放 setup() 里面\n这个还好说，用就是了，但是呢，我熟练的开始 this 然后惊人地发现得把 this 一层层往 setup() 里面引才能拿到最外面的 data 里面的数据容器，然后抱着疑惑的态度做了后震惊地发现 this 居然没有被定义（老人地铁手机.jpg），赶紧看了看文档\n啊这。。。那咋办呢，又查文档发现 setup() 可以传俩参数，setup(props, context)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export default { props: { title: String }, setup(props, context) { console.log(props.title) // Attribute (非响应式对象) console.log(context.attrs) // 插槽 (非响应式对象) console.log(context.slots) // 触发事件 (方法) console.log(context.emit) } } 我发现这里的 props 应该是和 Vue2 的 data 一样是可以被插值语句或者 v- 的语句拿到的，拿我是不是可以把 url 注到 props 里面呢，做了发现，不能 :cry:，props 里的数据只读。\n实在不行了，B 站里去找视频看，发现 Vue3 已经不把 data、methods 分开写了，setup() 里定义的变量也能直接被外界拿到 :cry:，那我直接放变量里不就行了。。。\n这个倒是解决了，但是呢，又有毛病了，我发现 ts 不能用 contact 连接数组，咋办呢，拿我用对象储存吧，对象也能 v-for。这下总算把数据渲染上去了。\n然而，问题又双叒叕来了，网页加载后，走马灯会中间会保持空白卡一会儿，然后才能正常运作，这我尝试了很多方法，没能解决，怀疑是 element-plus 的 bug。然后一气之下把 url 写成静态的，毫无毛病。。。\n但是呢，还残存了一些不足，加载图片速度不行，怀疑是图床不行，现在想想，为什么不直接把图片写成静态呢。\n搭建 Web 后端项目 Nodejs + express 搭建 Web 后端 Web 后端这边呢，还是用我熟悉的 nodejs 加上 express 框架，比起前端部分难为自己用 ts，果然还是 js 更加无拘无束。\n快速地 npm install express，因为需要解析 html 文件 send 到前端，所以需要 npm install art-template express-art-template，因为要解析前端请求体，所以要 npm install body-parser，后端使用的是 MongoDB（js 不香吗），为了更好的使用，我们采用 Mongoose 框架，npm install mongoose\n添加好请求头，做好跨域访问问题\n1 2 3 4 5 6 7 app.all(\u0026#39;*\u0026#39;, function (req, res, next) { res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;) res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild\u0026#39;); res.header(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;PUT,POST,GET,DELETE,OPTIONS\u0026#34;) res.header(\u0026#34;X-Powered-By\u0026#34;, \u0026#39; 3.2.1\u0026#39;) next() }) 把监听放在 80 端口，基本的初始化就完成了\n1 2 3 app.listen(80, () =\u0026gt; { console.log(\u0026#39;Serve is on...\u0026#39;) }) 然后连接数据库，这里之前踩过坑，在 mongoose.connect() 时要添加第二个参数 { useNewUrlParser: true, useUnifiedTopology: true }，通过将 useNewUrlParser 设置为 true 来避免 “不建议使用当前 URL 字符串解析器” 警告\n说道数据库就需要写一套 CRUD 来方便使用，目前只用到了 Create 和 Retrieve\n先说 Create，mongoose 操作的方法是先定义一个 Schema，形式类似 C 的结构体，这里的作用就像关系型数据库里的表（也是说 MongoDB 是最像关系型数据库的非关系型数据库的原因吧），这里定义的时候需要把 Schema 指向我们需要的 collection。然后使用 mongoose.model 在挂上这些 Schema，最后再对这些 model 进行 save 和 find 操作。\n值得注意的是，我们要将 储存、查询操作写成异步的方式，所以应该在查询函数中返回 Promise 函数，外部进行 .then 操作\n以上就完成了初始化和数据库处理，之后的任务就是根据需要开放各种各样的端口，也就是写 router，这里理论上应该把 router 单独放一文件中，然后引入，做的更模块化，这边项目比较小，所以先放一起。\n如果这些都做完，那一个简单的 Web 后端就搭建完成了（其实是在我所学范围内的东西全都用完了，叫啥来着，黔驴技穷？）。\n用 Go 重构后端 为啥要搞这一档子事呢，前言也说了，目前呢，也是抱着多学点东西的目的在搞\n学点 Go 从学校图书馆里借了四本书（其实只在看两本），学了大概一周，了解了个大概。这里只谈谈我觉得 Go 比较特殊的一些地方（相较我已经学过的一些编程语言，想到啥说啥）\n作为静态强类型的语言，Go 包含了丰富的数据类型，我们从 Go 的反射那里了解到有如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Kind uint const ( Invalid Kind = iota // 非法类型 Bool // 布尔型 Int // 有符号整型 Int8 // 有符号8位整型 Int16 // 有符号16位整型 Int32 // 有符号32位整型 Int64 // 有符号64位整型 Uint // 无符号整型 Uint8 // 无符号8位整型 Uint16 // 无符号16位整型 Uint32 // 无符号32位整型 Uint64 // 无符号64位整型 Uintptr // 指针 Float32 // 单精度浮点数 Float64 // 双精度浮点数 Complex64 // 64位复数类型 Complex128 // 128位复数类型 Array // 数组 Chan // 通道 Func // 函数 Interface // 接口 Map // 映射 Ptr // 指针 Slice // 切片 String // 字符串 Struct // 结构体 UnsafePointer // 底层指针 ) 我觉得 Go 比较好的一点就是可以在定义整型和浮点型的时候能够直接把位数写在类型上，如果不想写，Go 会智能地选择。其他的类型其实和 C 非常类似，比如结构体。\n当我们定义一个变量时可以使用 var，然后在变量名后加上数据类型，但是 Go 是比较智能的，你可以直接使用 := 让 Go 自己去判断拿到的数据类型（当然，是要赋初值的情况）\n注：其实 := 在别的地方我们也看到过，在 Python 中（3.8特性），它被称为「海象运算符」（确实挺可爱的），英文原文是 Assignment Expressions，使用它可以让 if 少写一行（当然，这只是个比较简单的例子，其实用处蛮多的）：\n1 2 3 4 5 6 7 # Before age = 20 if age \u0026gt; 18: print(\u0026#34;已经成年了\u0026#34;) # After if (age:= 20) \u0026gt; 18: print(\u0026#34;已经成年了\u0026#34;) 而在 Go 中，它被称为短变量声明符，这其实和 Python 的「海象运算符」并不是同一个玩意儿，毕竟 Python 作为面向对象的脚本语言，并不是强类型的（虽然确实可以添加强制类型的特性，就像 ts 对 js 那样的做法），你不可能让 Python 拿这玩意儿来进行数据类型判断（本身 = 就已经有这效果了）。\nGo 也有指针，和 C 很像，但个人认为比 C 更清晰，更不容易出问题。其实我在学 C 的时候，指针这块一直很晕，一直对指针这个东西的存在作用持有疑惑，也是在学 Go 的时候感觉对指针有了进一步的理解。\nGo 的代码风格感觉不太像 C 也感觉不太像 JavaScript 或 Python，它不会像 py 那样规定缩进，也不需要在语句结束的位置给上一个 ; ，条件语句不需要也不能用小括号把条件括起来，但它要求条件语句、循环这种需要大括号的语句需要把 { 和关键词放在同一行\n1 2 3 4 5 6 7 8 9 // Right if a \u0026gt; 11 { fmt.Println(\u0026#34;a \u0026gt; 11\u0026#34;) } // Wrong if a \u0026gt; 11 { fmt.Println } Go 还有一个很有特色的地方在循环语句，基本的循环和其他语言类似（只是不加小括号），主要是遍历，Go 采用的是 for-range 的形式：\n1 2 3 for index, val := range str { fmt.Printf(\u0026#34;index=%d, val=%c\\n\u0026#34;, index, val) } 你可以直接拿到被便利对象元素的序号和该元素本身，在 js 中会用 for\u0026hellip;in 和 for\u0026hellip;of 区分（前者拿到的是序号，后者拿到的是元素本身），这点很人性化。\nGo 的比较像 Kotlin 或者说 TypeScript，要求参数类型，并且要求返回值类型，不同点在于，Kotlin 和 TypeScript 有泛型的概念，使得函数内的某些数据的类型保持一致，而 Go 中没有泛型，但是 Go 能够使用指针（指针函数、函数指针、指向函数的函数指针 .etc ）\nGo 的函数不具有默认参数和可选参数，要求我们传入的数据都是自定的切确定的，虽然少了灵活，但从一方面来讲，它也更安全（当然，C 也没有）\n关于 Go 的函数，还有一点是比较特别的，它通过函数名的首字母是否大写来判断外文件是否能访问，当使用大驼峰命名（首字母大写），外部文件可以访问，而小驼峰（首字母小写）则作为一个内部的方法\n最后，也是最神奇的一点，Go 的函数可以有多个返回值，最简单的，当我们在读取用户输入时\n1 userInput, err := bufio.NewReader(os.Stdin).ReadString(\u0026#39;\\n\u0026#39;) 最后的 ReadString() 除了会返回一个 string 类型的数据外，还会返回一个 error\n1 2 3 4 5 6 7 8 9 10 11 12 func (b *Reader) ReadString(delim byte) (string, error) { full, frag, n, err := b.collectFragments(delim) // Allocate new buffer to hold the full pieces and the fragment. var buf strings.Builder buf.Grow(n) // Copy full pieces and fragment in. for _, fb := range full { buf.Write(fb) } buf.Write(frag) return buf.String(), err } 一般而言，我们会用一个变量 err 来装这个 error，但是必须对其处理，因为 Go 不能容忍有变量定义了却没有去用，当然你也可以使用下划线 _ 来忽略某返回值，但是多数情况下不被推荐\n以上就是目前在学习中了解到的一些比较有意思的东西，下面我们继续讲项目\n重构 第一次尝试用另一门语言去重构一个项目，因为项目比较简单，所以重构起来还算是比较容易的，更多的时间主要还是花在 debug 上\n重构的步骤也和之前搭项目的步骤差不多，这里我使用了 gin 框架来搭建项目，使用 mgo.v2 来进行 MongoDB 操作，总体体验还行\n这里就讲讲重构时的一些自我感觉比较好玩的地方或者 bug\n宏观上来看我写的项目，全都放在一个文件里编译，特别是 router，堆在一起，不够模块化。另外就是任然存在着代码的冗余——我只将数据库操作中的写入单独做了个方法，但并没有写查询，导致这块大量重复。另外就是 error 的处理，手段倒是挺多，可以 fmt.Println()，可以 log.Fatal()，在看一些教程的时候也有写到使用 panic()（让 go 感到「惊慌」），这个可能需要在学习一段时间，看点别人写的项目才能用得顺溜\n来聊聊 gin 和 mgo.v2 这俩东西吧\nGin is a web framework written in Go (Golang). It features a martini-like API with much better performance, up to 40 times faster thanks to httprouter. —— From https://gin-gonic.com/zh-cn/docs/introduction/\ngin 作为一个 Web 后端框架，其实就相当于 express，不过更像 express 的其实是上面这段引用提到的 martini：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // example in gin package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } // example in martini package main import \u0026#34;github.com/go-martini/martini\u0026#34; func main() { m := martini.Classic() m.Get(\u0026#34;/\u0026#34;, func() string { return \u0026#34;Hello world!\u0026#34; }) m.Run() } 拿我为什么会选择 gin 呢，实际上我也是刚刚看了下 martini 才发现他更亲切 :joy:，不过体验上还是差不多的，主要就是在写路由上。\ngin 在获取前端发过来的数据和从后端往前端发数据的时候，对参数的格式要求很严格，表单用一种方法承接，json 用一种方法承接。说道这个 json，你还得写个 struct，然后通过 BindJSON() 方法把 json 数据拿到，至少现在用着感觉还是有那么一点别扭。\nmgo (pronounced as mango) is a MongoDB driver for the Go language that implements a rich and well tested selection of features under a very simple API following standard Go idioms. —— From http://labix.org/mgo\nmongodb 的驱动在 Go 的 pkg 网站上有好多，看的教材也没有什么推荐，然后查了一下了解到这个驱动比较老牌，但是没有更新了。看了一下，还能用。主要就是 api 不好找，全英文读着还是很难受的（别骂了别骂了，在学了），不过逻辑还是比较简单的，多调试一下用起来不是什么大问题\n基本完成了这个简单项目重构好了之后，直接 go build 一下，然后把编译好的 .exe 文件丢到服务器上就可以直接用了（服务器是 Windows 的，Linux 等学了之后再说），不用像 node 那样，还得装一个。\n哦，别忘了一点，就是在打包使用时，在创建路由之前，将模式设置为 Release，这样可以关掉不必要的 debug 信息，关于日志管理，还有一个框架叫 logrus，我没用上，感觉比较复杂，就在这提一嘴，不过感觉这个东西还是有必要的，可能在后期会搞上这么一个。\n小结 这次写的还挺长的，就是写的有点乱七八糟的，不过挺随心的，真的就想到啥写点啥，不过应该预期想写的都写上了，还算不错。项目还有点东西要做，下一阶段再做总结。\n最后推荐一本 go 语言教材，《Head First Go 语言程序设计》—— [美] Jay McGavren。我很喜欢里面的箭头。\n","permalink":"https://akashiya-chime.github.io/posts/%E9%87%8D%E6%8B%BE%E5%89%8D%E7%AB%AF+%E5%90%8E%E7%AB%AF%E9%87%8D%E6%9E%84/","summary":"\u003cp\u003e本文包含并不限于以下内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e拿到 ECS 搞到域名后进行域名备案\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVite2 + Vue3 + TypeScript + Element-Plus 搭建前端项目\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003enodejs + express 搭建后端后使用 Go 重构后端\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"重拾前端+后段重构"},{"content":"最近又开始吹 uTools 了，老多推送推荐 uTools，说是「国产软件之光」、「全平台装机必备」、「黑科技神器」，诸如此类，吹得不要飞起。甚至有人评论：「用了 wox 之后，“listary 是什么垃圾？”，用了 utools 之后：“wox 是什么垃圾？”」\n个人最开始使用的是 Wox，其实在去年或是更早一些的时候（记不得了，感觉在疫情之前）就已经接触到 uTools 了，但是不久之后又乖乖滚回来用 wox，解释其原因，也就是此文的主要目的了。\n获取途径 官网： wox：http://www.wox.one/ utools：https://u.tools/\n软件的一些信息 拿来对比的版本 Wox：1.4.1196（本体开源） uTools：1.3.5（本体非开源） 更新情况 Wox：最近一次更新在 2020.5.26，目前可能已无更新，Github 里躺了接近 600 条 issue（598 Open，2369 Closed） uTools：最近一次更新在 2020.9.9（日期来自社区），更新速度还行，官方建了社区，用户在社区与开发者交流，提供版本bug、功能需求以及插件发布，官方回复速度可观 比较 软件大小 Wox：安装包 8.87 MB，安装后占用空间约 28 MB\nuTools：安装包 50.4 MB，安装后占用空间约 169 MB\n使用时内存占用情况 Wox：40-70 MB 左右（跳动较大，有时甚至上百） uTools：30 MB 左右（跳动不大） 插件 Wox：目前官方有289个插件，大部分来自外国开发者，实用的也就那几个，因为软件本身开源，所以插件开发上传是允许的。通过 wpm install 来安装： uTools：同样上百个，且几乎所有（我看到的都是）国内开发者开发的，极强的可读性，但实用的也确实只有那几个，好的是，官方开放了插件开发和上传途径，且文档中有比较详细的说明。通过自带的 UI 来安装： 在插件这一块，是两个软件核心的东西，但对于个人来说千差万别，每个人对插件的需要和理解是不同的。\n这里着重说最常用的 everything 的插件。\n两者都需要 everything client，everything 确实是一款非常不错的软件，对于文件搜索的速度快得飞起，但是会有一个问题，那就是 everything 的内存占用，动辄上百居高不下的内存占用，成为我开机内存占用最高的应用，但是如果不启动，wox 和 utools 都无法使用 everything 的插件功能\n这里提供一个 everything 的下载途径：https://www.voidtools.com/zh-cn/downloads/\n两者的区别体现在下面这几点：\nuTools 要使用 everything 插件（其实是所有插件都要）必须先键入关键词，而且不提供关键词的修改。相比较起来 Wox 就好了很多，wox 有关键词 *，可以不用输入关键词就可以进行搜索，而且，插件的关键词可以修改。 uTools 的搜索自带了文件类型分类以及预览模式，分类思想是好的，预览也对图片以及一些文字展示有好处，但是做为我个人使用的习惯，会用这种方式去打开某些常用的快捷方式，但是 uTools 并不配备搜索出的选项置顶的功能，让我很烦恼，甚至没有配置过滤选项还找不到快捷方式，而且过滤规则是值得研究的，有一定的学习成本。其他的一些常用功能（比如打开所在文件夹，拷贝，拷贝路径）两者都有，另外，Wox 还能以管理员身份运行 个人比较追求简约，Wox 提供自由的配色，对半透明的表现也非常令人满意，但是 uTools 就相对贫瘠了，本身只支持明亮与暗色两种主题，也只有修改透明度一个「效果不好」的滑条（透明会看不清文字）\n一些其他问题 收费：Wox 开源完全免费，uTools 开通会员会有云端数据备份（虽然感觉用不到，但是重装系统多了有点心虚）\n平台问题：Wox 似乎只能 Windows，uTools 支持 Windows，Mac，Linux\n文档问题：Wox 无，uTools 有比较完备（长）的介绍使用以及插件开发的文档（关于这点，文档是开发软件的一个优秀素质，但是从另一个方面来说，也体现了学习成本的区别，我 Wox 大多数功能用用就知道了，但 uTools 功能比较繁多，而且就连基础的一些功能也需要学习一下才能掌握，而且不保证记得住）\nuTools 有个鼠标中键的扩展功能，似乎可以语音输入，没怎么用（还是那句话，需要学），官方图：\nWox 因为具有全局插件的概念，所以一些常用的插件可以直接用，识别性也很好（比如计算器，复杂加减乘除用起来很爽，又比如打开 URL 等等） 结论 结论就是适合自己的就是好用的，uTools 确实好用，但对我的一些依赖性功能，他比较「慢」，要么是需要花时间配置或学习，要么是使用的步骤繁琐，但是他氛围好的社区以及插件发布更新是非常香的，很多插件确实吸引我的眼球，也许几个版本后，我也会放下 Wox 用上 uTools（因为实在是太香了）。\n最后，支持国产软件发展。\n{% note primary %} 2022年12月30日注：现在已经从wox切到utools了，utools优于其良好的更新以及广大的社区，现在已经发展地很强大很好用了，修了很多以前的恶性bug，综合体验上来讲，我认为utools已经胜过wox了。 {% endnote %}\n","permalink":"https://akashiya-chime.github.io/posts/wox%E4%B8%8Eutools%E5%AF%B9%E6%AF%94/","summary":"\u003cp\u003e最近又开始吹 uTools 了，老多推送推荐 uTools，说是「国产软件之光」、「全平台装机必备」、「黑科技神器」，诸如此类，吹得不要飞起。甚至有人评论：「用了 wox 之后，“listary 是什么垃圾？”，用了 utools 之后：“wox 是什么垃圾？”」\u003c/p\u003e\n\u003cp\u003e个人最开始使用的是 Wox，其实在去年或是更早一些的时候（记不得了，感觉在疫情之前）就已经接触到 uTools 了，但是不久之后又乖乖滚回来用 wox，解释其原因，也就是此文的主要目的了。\u003c/p\u003e","title":"Wox与uTools对比"},{"content":"开学的第一个月，还有两天，看看自己这个月干了些啥。玩了点游戏，看了点电影，做了点考研相关的安排，学了点东西（C语言）。以及，想想接下来这个月要干点啥，看些啥书，考研准备到哪里，要学点啥东西。\n嘀嗒清单 Surviving Mars Annihilation C Bash 美化 （想到啥写啥）\n干了些啥 嘀嗒清单（TickTick） 一款管理事件的 APP，也可以说是个 To-do List 软件。\n应该不算是 3 月的事情了，但是一直影响着 3 月的各种安排，所以拿来说说 个人其实没有很强的对一款「时间管理」软件的需求，就是无聊翻翻 Play 商店的时候发现了，看上去还挺好看，就下载下来将就用了，也算是对自己考研的一种激励吧。\n我装了安卓端与 windows 端的应用（开始只用安卓，但因为用电脑多点，而且自己手机实在是开得不能自已）\n安卓端 Win 使用还是挺清爽的，主要有 清单 番茄时钟 打卡 三个功能，都是顾名思义的功能，具体就不解释了，毕竟自己也是更多的因为好看才用的。\nSurviving Mars 《火星求生》，获得自 Epic 每周免费游戏\n其实本月也玩过另外一款类似的游戏 《City’s Skylines》（城市天际线，也来自 Epic 白嫖 :joy:），但游戏时长没这个长（虽然现在也卸载了），所以说这个。\n我的直观感受就是，《模拟城市》。作为一款纯正的模拟经营游戏，有其特有的「耗时间」的效果，一般能建个差不多得一大晚上。那这个游戏怎么玩的呢，游戏背景啊，就是人类派你到火星上殖民，最开始到火星的都是无人机（请联想《All-E》（机器人总动员）里的地球清理机器人），你需要收集火星上的资源，其中比较多且重要的就是混凝土、金属，然后为后期考虑需要水。等到资源收集得差不多并且地图上的资源都摸了个大概，就可以开始着手穹顶了。穹顶就是给殖民到火星上的人生活的场所，你首先需要给穹顶供应上足够的电、水和氧气，然后在穹顶中修建居民的住所，准备好后就可以用火箭载旅客来了。第一波的旅客是重要的，第一波旅客到达火星后会进入一段时间的观察期（地球人要看看火星是不是已经适合人类生存了），这段时间你不能再接旅客过来直到考察结束（我还没体验过考察失败会有啥结果 :joy:）。一般把人载过来不是看着好看的，模拟经营游戏的一个要素，也是推动游戏继续的一个要素就是经济，换在这个游戏里就是资金，资金的获取途径有好几种，有一种比较稳定的就是采集火星上的稀有金属，然后用火箭拉回地球卖，但是开采稀有金属的工厂是需要人来上班的，所以得把穹顶放这些矿近一些。另外，建造一些建筑需要的稀有材料也可以从火星上的矿上采集，但是，也需要人（所以拉人的时候筛选你需要的工具人，做恶心的资本家吧 :joy:）。\n其实游戏上手还是有一定难度的，自己也是把新手教程的几个关卡完成之后，重开了好几把才找到感觉。个人认为这游戏非常重要的就是运输机调度站，运输机可以自动跨地形把你需要建造的材料运到地点上，帮助你更好展开，所以前期就尽量点无人机的技能，尽快把这玩意儿开发出来，会好很多。\nAnnihilation [əˌnaɪəˈleɪʃn] （《湮灭》）\n个人是冲着「克苏鲁风格」的这个介绍去看的，虽然很多人评论反对这种说法，个人并不想参与其中，但就看这个电影讲了个什么故事，和一些个人理解与体会。\n电影讲述了由五个女性科学家（生物学家、心理学家、物理学家、地理学家和医务护理，好吧最后一个不算科学家 :joy:）进入 shimer（微光）中调查奇怪陨石的故事，其中不乏看到开膛破肚、肠道蠕动、变异生物以及疯了的调查员，咳咳，疯了的同伴。\n比较喜欢的一点是故事里 shimer 中有「镜子」这个属性，里面的一切都在互相「照镜子」生物的基因在模仿、同化，剧情中就有一个人被编译生物咬掉喉咙，然后那个生物会说人话这个情节，也有人变成周树人这种情况。\n剧情最后就是一个名场景了：\n这个一身金属光泽的，可能为外星生物的人形模仿这主角的动作，但又不完全模仿（会阻止主角的逃离），最后逐渐变成主角的模样，主角看着他，就好像在照镜子，他们两个就像物质与暗物质，他们几乎一模一样，最后主角将白磷弹递到对方手中，在一阵强烈的白光下主角得以逃出。但凡是进入了 shimer 的人都在改变着，虽然主角看似正常。故事的最后，主角与丈夫拥抱，主角眼中流出淡淡的微光。当那个外星生物在模仿她的时候，她，也在模仿对方，就像是，在照镜子。\n物质与其所对应的反物质碰撞后消失并产生高能光子（γ射线）等能量的过程，例如电子与正电子的碰撞，称之为湮灭。 ——《百度百科》\nC 总结，学 C 学了 13 天，学到内存池，还没学 typedef、共用体、枚举类型、位域位操作、文件\n其实也不是很像学 C，但是考研要用，没办法\n其实学到现在也只是知道 C 被广泛应用在嵌入式系统开发，但是怎么百度也搞不太明白，而且很难的样子，不太想深入\nC，确实很快\nC 会产生一些莫名其妙的错误（专门从图书馆借了本《C Traps and Pit Falls》（C 陷阱与缺陷），但是没想到是本全英文的，啃着有点难受），练习的时候写了个求 e 的程序，然后各种有输入没输出，最关键的，它没有报错。用 JS 写，一遍就出来。。。不过还是最后把问题都排查出来了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //e.c #include \u0026lt;stdio.h\u0026gt; float jie(int n); int main() { int n; float e = 1.0; printf(\u0026#34;please give a n: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (; n \u0026gt; 1; n--) { e = e + (1/jie(n)); } printf(\u0026#34;e = %.10f\\n\u0026#34;, e); return 0; } float jie(int n) { float res = 1.0; int i; for (i=1;i\u0026lt;n;i++) { res = res * i; } return res; } Bash 美化 捣鼓了一天 Windows 的 Linux 子系统，主要就是在搞这个 Bash 的美化，最后还是小有些成果\n主要讲下步骤：\n先搞到 Linux 子系统\n设置 - 更新和安全 - 开发者选项 - 开发人员模式\n设置 - 应用 - 应用和功能 - 相关设置 - 程序和功能 - 启用或关闭 Windows 功能 - 适用于 Linux 的 Windows 子系统 -确定\n然后在 Microsoft Store 下载 Windows Terminal 和 Ubuntu（下载的 Ubuntu 会自己添加到 Windows Terminal 中）\n注意，在安装完 Ubuntu 后，第一次打开会创建账户，请记住密码 美化 Windows Terminal\n打开 Windows Terminal，进入设置（Ctrl + ,）\n配置是 json 格式的，方便我们修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 { // 这里放默认打开时的窗口，默认是 Powershell，我换成了 cmd // 值就是下面 profiles -\u0026gt; default -\u0026gt; list -\u0026gt; guid \u0026#34;defaultProfile\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;initialCols\u0026#34;: 100, // 初始宽度 \u0026#34;initialRows\u0026#34;: 25, // 初始高度 \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { // Put settings here that you want to apply to all profiles. \u0026#34;acrylicOpacity\u0026#34;: 0.5, // 背景透明度(0-1) \u0026#34;useAcrylic\u0026#34;: true, // 启用毛玻璃 \u0026#34;backgroundImageStretchMode\u0026#34;: \u0026#34;uniformToFill\u0026#34;, // 填充模式 // \u0026#34;fontFace\u0026#34;: \u0026#34;Cascadia Code\u0026#34;, // 字体，我最开始用的上面的巨硬字体，但因为 Powerline 的原因换了 \u0026#34;fontFace\u0026#34;: \u0026#34;Fira Mono for Powerline\u0026#34;, \u0026#34;fontSize\u0026#34;: 12, // 文字大小 \u0026#34;colorScheme\u0026#34;: \u0026#34;Moonlight II\u0026#34; // 主题 } }, \u0026#34;schemes\u0026#34;: { // 主题文件，这里放的是我用的 Moonlight II { \u0026#34;name\u0026#34;: \u0026#34;Moonlight II\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#191a2a\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#ff757f\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#c3e88d\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#ffc777\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#82aaff\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#c099ff\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#86e1fc\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#c8d3f5\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#828bb8\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#ff757f\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#c3e88d\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#ffc777\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#82aaff\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#c099ff\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#86e1fc\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#c8d3f5\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#222436\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#c8d3f5\u0026#34; } } } 保存重启就完成了 Windows Terminal 的美化\n另外，你还可以在这个网站找到你喜欢的主题：Windows Terminal Themes\n给 Bash 添加 Poweline\n为了保证完成的速度以及可靠性，我们给 apt 换成清华大学的源 sudo vi /etc/apt/sources.list（如果不行，那就用 gedit） 访问清华 apt 源网站，选择合适版本：清华大学开源软件镜像站 复制粘贴，保存退出（:wq） sudo apt-get update 完成 Powerline 是 python 的一个库，所以需要 pip sudo apt-get install python-pip 然后需要 git：sudo apt-get install git pip 安装 Powerline：pip install git+git://github.com/powerline/powerline 这里经常出错，大多数原因是因为 github 服务器的连接问题 安装 Powerline 对应的字体，一般来说，在 Linux 系统下直接 wget 到 github 仓库拿，但是首先现在 github 基本访问不上，挂代理高配置又很复杂，齐次，就算拿到了也用不了，因为你运行在 Windows 下的 Windows Terminal 下面。所以你应该是给 Windows Terminal 配置上 Powerline 字体，这里建议百度下载字体，或者到 github 仓库（colepeters/fira-for-powerline: Fira Mono with Powerline symbols patched in. (github.com)），然后在 Windows 下安装，最后配置到 Windows Terminal OK，安装完成，重启 Windows Terminal，bash 回车\n琐碎 《怪物》真好听，YOASOBI 永远滴神 C 还得继续学完\n借了两本 UML 的书回来，准备学学\n推荐一本书：\n《日语语言学理论研究与日本文化探析》（赵敏著.——北京：中国水电出版社，2017.3，ISBN：978-7-5170-5098-8）\n有助于日语学习与了解日本文化，书里讲了很多日语教材里没有的东西，是个很不错的拓展读物。\n以上。希望 4 月也能有点动力，好好准备考研呢。\n","permalink":"https://akashiya-chime.github.io/posts/3%E6%9C%88%E6%9C%88%E6%9C%AB%E6%80%BB%E7%BB%93/","summary":"\u003cp\u003e开学的第一个月，还有两天，看看自己这个月干了些啥。玩了点游戏，看了点电影，做了点考研相关的安排，学了点东西（C语言）。以及，想想接下来这个月要干点啥，看些啥书，考研准备到哪里，要学点啥东西。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e嘀嗒清单\u003c/li\u003e\n\u003cli\u003eSurviving Mars\u003c/li\u003e\n\u003cli\u003eAnnihilation\u003c/li\u003e\n\u003cli\u003eC\u003c/li\u003e\n\u003cli\u003eBash 美化\u003c/li\u003e\n\u003c/ul\u003e","title":"3月月末总结"},{"content":"用电脑有一（亿）段时间了，也常常在尝试一些稀奇古怪的软件，做一个相当于 mark 一样的玩意儿（免得重装系统懒得找），包含但不限于知名或不知名的（Win10）美化软件、插件或者是工具。\n代表个人习惯，用的舒服才是好的。\nWin10 美化 BitDock 官网：http://www.bitdock.cn/\n官方视频：https://www.bilibili.com/video/BV1eE411A7ht?zw\n预览图：\n给 Win10 整个 Mac 的 Dock 栏，挺好看的，还有一定的动画过渡。 支持几个皮肤，图标样式也可以换换。 比较喜欢这个软件带的 LaunchPad，可以把桌面的图标都放进去，快捷键呼出，让桌面简洁 支持快捷键显示隐藏（建议把鼠标靠近边缘呼出关了，用快捷键呼出，不然打游戏有的好受，osu 打谱的时候被恶心到了）。 内存占用大概有个 30MB 左右（BitDesk 比特桌面、BitDock 比特工具栏）。 开机启动速度还行，稍有延迟（我自己电脑不太行）。 比较喜欢的一点是可以把 Win10 任务栏放进去，这也是我选这个而不是其他的同类软件（下面说说）的一个原因。 可以放个时钟和日历。 其实还有一些同类型的，也挺不错的仿 Dock 软件，这里提一下（用不太惯）\nMyDockFinder\n官网：https://www.mydockfinder.com/ 怎么说，其实我用过一段时间，美化方面比 BitDock 好太多了，甚至把 Mac 顶部的部分也加上了，官网上都罗列出来了，就不细说了，更新频率还挺快的，也许以后有我欣赏的更新，我会再转过去用它（真香）。 好了，是不是差不多已经把 Win10 自带的任务栏的功能都包括进去了呢:smirk:，那么接下来把 Win10 自带的删了吧\nTaskBarHider 有时候不满足于 Win10 自带的隐藏任务栏了，迟钝，有点难受，这个软件可以用快捷键显示隐藏，挺方便的\n获取：https://zyhh.me/delphi/taskbarhider.html 原本的快捷键是 Ctrl + ~，因为和我的快捷键冲突了，所以我改成了 Alt + ~。\nRolan 官网：https://getrolan.com/ 一款。。。额。。。侧边栏 Dock，虽然现在已经不用了，但是还是放这里说说，之前用着确实挺不错的（因为有 BitDock，而且更新后把 LaunchPad 做得人性化了一点，就取代 Rolan 了）。\n因为已经没在用了，所以预览图上官网看看，现在版本是 Rolan2，Rolan3 等了好久都还在预览版。。。\n然后。。。这软件基本功能（我能用上的）免费就能用，一些别的（比如美化自身？）就要 pay 了。\nWallpaper Engine 挺有名的一个动态壁纸软件了，steam 上买的十多块，也不是特别贵，体验上还行（最近开机启动稍有延迟，不知道是不是我重装系统后出的毛病）。\n没怎么用过别的动态壁纸软件，没什么比较 ，性能的影响上，感觉在加载一些比较「质量上乘」的动态壁纸的时候，占内存比较多（对我来说），还会占用一点 GPU 去处理（所以现在还用着静态的壁纸）。\n优势在于一个庞大的社区，一旦购买软件，社区中的图都可以下载\n工具 想到啥写啥，就不追求啥顺序了\n小黄条 官网：https://www.yynote.cn/ 就。。。很简单的一玩意儿，在桌面上摆着，记点事啊，要做的事啊之类的，官方的意思是把这玩意儿当 Todo List 用，也行\n官网预览图：\n手心输入法 官网：http://www.xinshuru.com/ 在长期饱受微软拼音输入法的迫害之后，决定换一款输入法。\n但是路途是曲折的，其实最先想到的是搜狗、百度这些「耳熟能详」的输入法，但是实在是怕他「夹带」一些不明所以影响体验的玩意儿，加上或多或少的弹窗、广告等等，又或者是可能出现的臃肿，就没有怎么有想法了。但有这个初衷，实际上来自于对微软拼硬词库的极度欠缺，而搜狗、百度的词库在当下国内确实是数一数二的。\n然后经过几番寻找，找到一个叫 Rime 的输入法（或者叫小狼毫？），这个软件开源，给我的感觉就是，特别高级，非常的强大，加上其强大的自定义功能，那简直就是。。。额。。。输入法界的 Vim。导致新手接触这玩意儿甚至都不知道退出是 :q 。\n我接手 Rime 开始花大量的时间去了解，去学习，但回头却发现根本不值得，我并不需要他的复杂强大的功能，也没必要为了美观和基本的词库（也是在这个时候知道每家输入法的词库文件是不互通的）去调试然后百度各种报错。简洁轻巧才是我追求的。\n机缘巧合之下，在某次重装系统之后，刚好受到个推送，发现了手心输入法，简洁而不缺乏功能，自带的词库和联想也能够满足我的需要，所以一直使用到现在。\n{% note primary %} 2022年12月30日注：据说手心被360招了，官网上最后一次更新停在了2018年10月18日，最近的更新好像在360软件市场，可以找找贴吧老哥发的抽离版 {% endnote %}\nEverything \u0026amp; Wox Everything：https://www.voidtools.com/zh-cn/ Wox：http://www.wox.one/ Everything 应该被很多人所知，其强大快速的文件搜索功能确实独一无二，很多人做了很多的介绍推荐，还有很多开发者热衷于给 Everything 做拓展（比如EverythingToolbar，可以将 Everything 嵌入 Win10 的任务栏里面，或许如果我没用 BitDock 就试试了）或者让自己的软件搭载 Everything 的功能，就比如这里的 Wox。\n那么来说一下 Wox：\n快捷键呼出，直接搜索，用 Everything 秒出结果，点击打开，非常的人性化，还可以挂在一些插件达到例如颜色查询、计算器或者 cmd 的功能。\n但是这个软件有个弊端，要使用 Everything 的功能需要 Everything 服务保持打开，但是这玩意儿占内存就有个七八十 Mb（重装系统那会儿发现占了 200Mb 是我没想到的，可能哪里设置错了），但是比起他带来的便捷，这个还是能够忍受的。\n其实比起 Wox，前段时间收到很多推送是 uTools，在发现它之后我也确实用过一段时间，确实，挺好看的，功能挺多的，但是，我不喜欢，就使用 Everything 打开文件就感觉它做的不好，不够简洁。\n其实还有很多，留点有时间又写\n","permalink":"https://akashiya-chime.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/","summary":"\u003cp\u003e用电脑有一（亿）段时间了，也常常在尝试一些稀奇古怪的软件，做一个相当于 mark 一样的玩意儿（免得重装系统懒得找），包含但不限于知名或不知名的（Win10）美化软件、插件或者是工具。\u003c/p\u003e\n\u003cp\u003e代表个人习惯，用的舒服才是好的。\u003c/p\u003e","title":"软件汇总"},{"content":"混了一个假期，想想在假期里干了些啥，包括但不限于：\n《地铁最后的曙光》 《为了吾王》 《我们的父辈》 《Metro: Last Light Redux》 《地铁：最后的曙光重制版》（也就是地铁2034，至于重置和原版有啥区别，没玩过原版）\n应该是放假不多久玩到的游戏，具体原因是 Epic 白给:grin:。放假前（期末考试期间）玩过《Metro 2033 Redux》（其实也是 Epic 白给才玩到的），感觉还不错，能白piao续作还是很开心的\n地铁系列，包括2033，归来和离去三部（听说归来是2033重置和最后的曙光的大包），4A家的废土（末世？）题材的FPS，改编自小说《地铁2033》《地铁2034》，故事背景简单说是核战争之后的世界（又是核平的一天呢）。类似题材的废土，就有育碧家的《辐射》系列了，核战争确实是个值得思考的背景。另外这个游戏的背景比较有意思的是，故事发生在俄罗斯，少有的可以在毛子的国家打枪，体验废土下毛子风土人情的游戏。关于这游戏的背景，还有一个趣闻（不知道是真是假），听说好莱坞拿到了电影翻拍权，但是觉得应该把故事发生的国家改在美利坚，但受到作者强烈反对，认为这样的故事在美国根本不可能发生（倒也确实），后面就破裂了，听说现在还在寻找合适的合作。\n以下内容涉及部分剧透，请酌情观看\n由于是 Epic 平台下玩的，官方没有中文，补丁找到的 Steam 版的，但是不适用，讲究玩着英语版的，其实不是很难理解游戏剧情与游玩（雾，操着六级刚过的英语水平），当然，原汁原味还是应该选毛语，但是听不懂看不懂字幕就很难受了。值得一说，虽然选的英语，但是毛式英语听着也别有一种乐趣与体验。\n说是有剧透，但其实我也没太关注剧情，之前想买小说看看的但是有网友评论说官方中文的翻译有点难受（联想到了之前看《克苏鲁神话》），所以就没下决心。《最后的曙光》的剧情是延续之前《2033》的，前作里面移居地铁的人们受到一种被称作 the Dark Ones 的生物袭击，致使生存再次受到威胁，主角 Artyom 一路前往地铁中心 Polis，并在最后登上高塔，定向导弹，来了波偷家。这部著作就延续在一年后，依我看这一部有两条线索，一个是发现 the little Dark Ones，并找回起同伴；另一条是纳粹和红军的斗争。故事最后救回了 the little Dark Ones 的同伴，主角也在红军和纳粹的斗争中，最后在 D6 引爆炸弹同归于尽。但是听说本作和前作一样有两个结局（什么？有俩结局？2033也有俩？），但没具体调查过真假，也就不作过多阐述。\n游戏体验上还是挺不错的，有很多细节的东西。枪械方面虽然种类不是很多，但是配备了武器改装（虽然也不是很多就是了）。除了一些常规的枪械，比较特别的就是两类特有的，一种通过压缩气体射飞镖，另一种通过电磁射钢珠，这两种武器不仅需要上子弹（捡到子弹少的可怜，携带也少），还需要手摇来压缩气体或者充电，威力还行，特点是声响小。关于武器还有俩可以一谈的，一个是虽然有近战小刀，但是设计者并不觉得你可以拿它打架，伤害低的可怜（刮痧），主要作用是拿来做一些场景交互和 QTE（怪扑身上拿刀捅）；另一个是，这游戏的货币是军用子弹······这带来一个什么效果呢，我经常在给我 AK 上子弹的时候会装错（长按 R），然后就是打的钱啊:sob:，不过金钱的力量确实强，甚至还能带来燃烧效果:joy:。\n游戏里有两种敌人，一种是“人”，一种是一群长的像大狗的怪物（怪物还分很多种，根据毛色和体型分别，虽然我觉得都很像就是了），这一部里面还多了点水里游的，会钻出来打你，还很肉。说起这个游戏打怪，就不得不说，我觉得这就是个恐怖游戏，打人特别简单，这游戏人的AI比较傻，甚至能当个刺客（战士信条真好玩），拿飞刀一个一个解决（或者小刀背刺）。但是怪物可太难了，主要是剧情大多在地下，很阴间，靠着个忽明忽暗的手电（这里值得一提的是，游戏中的光源是需要手摇发电的，另外还有个打火机可以照明，因为有的地方电子器械被干扰了还黑的很，不得不点个打火机，另外打火机还可以烧蜘蛛网，点火把），虽然后面可能捡到夜视仪，但夜视仪也很阴间，然后那个怪啊就像恐怖游戏里的 jump scare，突然就跳出来，还一堆，移动速度还快，攻击速度更快，频率也高，有的关卡甚至有从洞里面爬出来给你一下就跑的，着实阴间恐游。\n游戏有个和废土有关的特色就是面罩。虽然大多数时候是在地铁中活动，但是也时不时会上到地面（这部里面见到了克里姆林宫，虽然我没仔细看）。因为背景是核战争之后，地面上辐射很重（空气有毒？），需要戴个防护面罩（面罩可能会被血液或者泥土弄脏影响视野，设计者“贴心”的设计了一个“擦面罩”的功能），需要过一段时间换个滤嘴。在玩前作的时候，一直不知道怎么看自己滤嘴还能撑多久，只能根据一些反馈来做判断（快完的时候会提示按“T”更换滤嘴，再过一段时间会听到主角在喘气），但是前作开始的时候滤嘴还很多，我甚至觉得这只是个装饰，没实用，就一直戴着，甚至在地下的时候也不摘，后面卡关卡了半天（恨不得 NPC 说话快点）。\n以上就是这个我游戏体验的大概了，还有很多剧情、场景、玩法上的细节就不多阐述\n《For The King》 《为了吾王》\n也是 Epic 上白piao到的游戏，其实很早之前就已经领到了，并且和朋友联机玩过一段时间，但一直没通关，这次 Epic 梅开二度又送了一回，刚好让兄弟领了一起快乐一下。联机了几次，最终没能一起通关，前两天我又自己重开一个单人的服，花了一晚上多一点的时间终于通关了一次。\n这是一部具有龙与地下城（D\u0026amp;D）风格（现在叫Roguelike？）的游戏，三人回合制，有熟悉的属性机制和概率判定，难度和游戏体验还是可以的，但不得不说 Epic 送游戏不送服务器这个问题，玩个对延迟要求不是很高的 RPG 都要挂加速器。不过作为一个跑团爱好者，这个游戏还是很能满足我的胃口的。\n我只通关了基本的模式，还有几个模式没有过多去体验，等有想法的时候再说。\n《Unsere Mütter, unsere Väter》 《我们的父辈》（百科）（豆瓣）\n我说是电影，但百科给我说是迷你剧:joy:。了解到这部作品的原因是因为上上上学期，选了个德语二外的课，然后老师拿了两讲课作为拓展给我们放这个作品，当时没看完，这个假期陪家人过年一起看补完了（感谢朋友的b站大会员）。\n故事背景是在二战，本作是站在德国的五个青年人的角度看待的这场战争，也是围绕着这五个朋友（Fünf freunde）在这场战争中所扮演的角色来引发观众的思考。其中不乏有看到诸如“水晶之夜”、“莫斯科保卫战”等历史事件的背后，以及“歧视犹太人”的现象。看完之后感触挺大的，我对历史的兴趣不是很大，但这部作品确实让我看到历史发人深省的地方，印象最深的也是本作主题的一句话：“战争只会把我们最坏的一面展现出来。”\n《我们的父辈》给予至今幸存的德国二战一代，向他们亲人讲述自己二战故事的机会。（《法兰克福汇报》评 ）\n另外，作品中的德语歌《Mein kleines Herz》还挺好听的\n琐碎（给自己看的） 放假前计划继续进行的一个 PC 端阅读器 Neko-Reader 一点也没有动过:sweat:，还不知道啥时候能动呢（所以 CSS 什么时候学？）\n因为计划考个软件工程，所以买了本《计算机网络》，应用层看完了，运输层看了点，基本都是年前看的，年后因为陪家人、到处拜年、和朋友玩（快找点理由），所以基本没看，这书还有个 2/3 的样子吧，下学期课多，还有另一门专业课《软件工程》没看，不知道得不得行啊这考研。\n做了个 DM 帷幕，材料是 pp 板和螺栓（螺栓买少了，导致打了洞没钉，不过还是稳的），说起螺栓，还有门钢结构设计原理要补考，啥时候复习呢。\nC 语言学到指针了，前边基本都是复习，因为有过《计算机程序设计基础》的课，学起来给我的感受就是，很繁琐，有各种各样的问题（还是 JavaScript、Python这种简单的适合我），但是考研要复试，那我的优势在哪呢？\n因为 Edge 更新不了，尝试更新 win10 失败，导致重装了一次系统，花了大概两天时间恢复到 95% 大概可以使用。\n有了兴致 LOL 上了白银（潘森真好玩）\n后话 想写个软件推荐，以上 ","permalink":"https://akashiya-chime.github.io/posts/%E5%81%87%E6%9C%9F%E6%80%BB%E7%BB%93/","summary":"\u003cp\u003e混了一个假期，想想在假期里干了些啥，包括但不限于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e《地铁最后的曙光》\u003c/li\u003e\n\u003cli\u003e《为了吾王》\u003c/li\u003e\n\u003cli\u003e《我们的父辈》\u003c/li\u003e\n\u003c/ul\u003e","title":"假期总结"},{"content":"之前为了学习 Vue2 而去学了点 webpack 的基础，然而现在尤大发布 vue3 之后自己整了一个 vite，那这不得不去再学 vite\n文章放 CSDN 上了：\nhttps://blog.csdn.net/Akashiyachime/article/details/106841056\n前端资源构建工具，静态模块打包器\n坑： 如果你webpack和webpack-cli是局部安装的，想要使用webpack命令必须进入node_modules/.bin/webpack才能执行webpack命令，.bin目录包含的是一系列可以执行的命令，但是如果你是全局安装的webpack-cli，就不需要进入bin目录，webpack就能够寻找到它的命令路径了，以上是我的个人总结 （所以说啥本地安装啊，还是安全局的吧。。。）\n核心概念 Entry 入口(Entry)指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 Output 输出(Output)指示Webpack打包后的资源bundle输出到哪里去，以及如何命名 Loader Loader让Webpack能够去处理哪些非JavaScript文件(Webpack自身只理解JavaScript) Plugins 插件(Plugins)可以用于执行范围更广的任务。插件范围包括，从打包优化和压缩，一直到重新定义环境中的变量等 Mode 模式(Mode)指示Webpack使用相应的模式的配置 流程 index.js： Webpack 入口起点文件 运行指令： 开发环境：webpack ./src/index.js -o ./build/built.js \u0026ndash;mode=development webpack 会以 ./src/index.js 为入口文件开始打包，打包后输出到 .build/built.js 整体打包环境是 开发环境 生产环境：webpack ./src/index.js -o ./build/built.js \u0026ndash;mode=production\n结论： （1）webpack 能处理 js/json 资源，不能处理 css/img 等资源 （2）生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化 （3）生产环境比开发环境多一个压缩 js 代码\n打包样式资源 src 同级目录下创建 webpack.config.js 文件，该文件是 webpack 的配置文件 作用：指示 webpack 工作（运行 webpack 指令时，会加载里面的配置）\n所有构建工具都是基于 node.js 平台运行，模块化默认采用 commonjs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // resolve 用来拼接绝对路径的方法 const { resolve } = require(\u0026#39;path\u0026#39;) module.exports = { // webpake 配置 // 入口起点 entry: \u0026#39;./src/index.js\u0026#39;, // 输出 output: { // 输出文件名 filename: \u0026#39;built.js\u0026#39;, // 输出路径 // __dirname 是 node.js 的变量，代表当前文件的目录绝对路径 path: resolve(__dirname, \u0026#39;build\u0026#39;) }, // loader 的配置 module: { rules: [ // 详细的 loader 配置 // 不同文件必须配置不同的 loader 处理 { // 匹配哪些文件 test: /\\.css$/, // 使用哪些 loader 进行处理 // 当要使用多个 loader 时，需用 use: [] use: [ // use 数组中 loader 执行顺序：从后到前，依次执行 // 创建 style 标签，将 js 中的样式资源插入进去，添加到\u0026lt;header\u0026gt;中生效 \u0026#39;style-loader\u0026#39;, //后执行 // 将 css 文件变成 commonjs 模块加载 js 中，里面内容是样式字符串 \u0026#39;css-loader\u0026#39; //先执行 ] } ] }, // plugins 的配置 plugins: [ // 详细的 plugins 配置 ], // 模式 mode: \u0026#39;development\u0026#39; // 开发模式 // mode: \u0026#39;production\u0026#39; //生产模式 } 打包html 需要一个 plugin：html-webpack-plugin 1 2 3 4 5 6 7 8 9 10 11 12 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) module.exports = { plugins: [ // 默认创建空的 HTML，自动引入打包输出的所有资源（JS/CSS） // 需要有结构的 HTML new HtmlWebpackPlugin({ // 复制 \u0026#39;./src/index.html\u0026#39; 文件，并自动引入打包输出的所有资源（JS/CSS） template: \u0026#39;./src/index.html\u0026#39; }) ] } 打包图片资源 需要一个 loader： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module.exports = { module: { rules: [ { // 问题：默认处理不了 html 中引入图片（可处理样式中的图片） test: /\\.(jpg|png|gif)$/, // 当只有一个 loader 时，可直接loader: loader: \u0026#39;url-loader\u0026#39; option: { // 图片大小小于 8kb ，就会被 base64 处理（一般 8~12kb） // 优点：减少请求数量（减轻服务器压力） // 缺点：图片体积会更大（文件请求速度更慢） limit: 8 * 1024, // 8kb // 问题：因为 url-loader 默认使用 ES6 模块化解析 // 而 html-loader 引入图片是 commonjs // 解析时会出问题：[object Module] // 解决：关闭 url-loader 的 ES6 模块化，使用 commonjs解析 esModule: false, // 给图片进行重命名 // [hash:10] 取图片的 hash 前10位 // [ext] 取文件原来的扩展名 name: \u0026#39;[hash:10].[ext]\u0026#39; } }, { test: /\\.html$/, // 处理 html 文件的图片（引入 img，从而能被 url-loader 处理） loader: \u0026#39;html-loader\u0026#39; } ] } } // 最终图片的名称是一个 hash 值 打包其他资源 一些不需要进行压缩等处理的文件 1 2 3 4 5 6 7 8 9 10 11 12 13 module.exports = { module: { rules: [ // 打包其他资源（除了 html/js/css 资源以外的资源） { // 排除 exclude: /\\.html|js|css$/, loader: \u0026#39;file-loader\u0026#39; } ] } } // 也是 hash 值（也可以用 options 处理一下） ","permalink":"https://akashiya-chime.github.io/posts/webpack%E6%89%93%E5%8C%85%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003e之前为了学习 Vue2 而去学了点 webpack 的基础，然而现在尤大发布 vue3 之后自己整了一个 vite，那这不得不去再学 vite\u003c/p\u003e\n\u003cp\u003e文章放 CSDN 上了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/Akashiyachime/article/details/106841056\"\u003ehttps://blog.csdn.net/Akashiyachime/article/details/106841056\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e","title":"Webpack打包基础"},{"content":"少女找乐子中","permalink":"https://akashiya-chime.github.io/about/","summary":"\u003cdiv style=\"text-align: center!important\"\u003e少女找乐子中\u003c/div\u003e","title":"关于"}]